{"./":{"url":"./","title":"wyfyjc.com 惟愿","keywords":"","body":"Mr.Zhou Blog Just hope, in the wind and rain of the night can also move forward. 最近更新 Wed Jun 09 2021Rust > 2021 年Rust > Rust 基础Tue Jun 08 2021Rust > 结构体Rust > 所有权 个人联系方式：邮箱、掘金 前言 忙活了些许天，选定了 GitBook 作为文档工具，并做了一些微小的调整 在这之前，尝试搭建分离的动态博客，也试着手敲静态网站，鼓捣了 VuePress 等一系列的静态生成器 GitBook 的默认样式是不错的，提供了丰富的插件支持，也省去了动态博客频繁的维护、升级花费 目前，由于国内云主机的备案问题，博客暂时部署在国外的服务主机（GitHub Pages） 对于之前积攒的文章，会逐一修改，大概可以保持每周一到三更的频率，具体的更新时间并不确定，可能是夜里或是早晨 博客缘由 博客内撰写的文章，主要是关于个人的学习整理，受限于目前的水平，仅供参考使用 这里，简单介绍下，关于我个人对于知识大纲梳理的缘由 写博客、做记录的缘由很简单：人的大脑内存是有极限的，而博客则是近乎无限的外设存储 以计算机为例，可以理解为：内存是高效而狭小的，硬盘则扮演低效、广大的角色 当个人为了一个曾经解决过的问题而烦恼时，记录博客的欲望也就愈发高涨，这也是缘由 JDK 环境配置 工欲善其事，必先利其器。目前，最为主流的 JDK 是 Oracle JDK，这里也采用该 JDK 发行版做全套的讲解 进入 Oracle 官网，下载 JDK 文件并解压存放（推荐使用压缩包进行安装），存放路径以全英文为最佳 在系统变量中写入如下信息（不建议将路径直接写入 path 变量，不利于 JDK 版本切换） 变量名：JAVA_HOME 变量值：JDK 的存放路径，例如 D:\\JDK\\JDK11 在系统变量 Path 中写入如下信息 %JAVA_HOME%bin 打开 cmd 窗口，输入 java -version，确认版本 对于环境变量的位置：文件资源管理器 - 此电脑（右击 属性）- 高级系统设置 - 切换至高级选项卡 - 环境变量 若是烦于 Oracle 的账号注册（登录下载 JDK），可以在学习阶段选用 Open JDK，在使用上无较大差异 当然，个人还是建议注册 Oracle 账号，下载 Oracle JDK，并不确定二者在源码的实现上否相同，是否会影响到 Java 常用类的阅读、分析等 IDEA 安装 一款强大而智能的 IDE 是你职业生涯的最佳拍档，人性化的 IDEA 是不错的选择 以下通过 Windows 平台作为介绍（买不起 Mac，用不着 Linux） 下载地址：https://www.jetbrains.com/zh-cn/idea/download/#section=windows 在安装界面，只需要勾选如下（区分 zip、exe 格式的安装） 勾选操作系统位数 勾选 path 环境变量（建议由 IDEA 代为完成） 其它根据需要，自行选择即可 IDEA 的插件、配置很重要，这里只介绍几款插件、配置，其中最核心的是汉化插件 汉化：官方提供有汉化插件的支持 顶部导航栏 File 下拉选项 Settings...（快捷键 Ctrl Alt S） 选择 Plugins，切换选项卡为 Marketplace 搜索框输入：Chinese (Simplified)，下载并重启 扩大内存：流畅的 IDEA 使用体验，需要足够的内存作为支撑 帮助 --> 更改内存设置 根据的自己的需要调整分配的内存大小，保存并重启 视图 --> 外观 --> 状态栏微件 勾选内存指示器，并在 IDEA 右下方查看当前内存使用情况 IDEA 插件：插件可以拓展 IDEA 的功能，极其重要，这里仅介绍一款前期通用插件 代码扫描：Alibaba Java Coding Guidelines，用于纠正开发规范 格式调整：IDEA 默认的代码排版格式可能存在问题，例如注释的缩进位置 文件 --> 设置 --> 编辑器 --> 代码风格 更多的自定义配置请自行摸索，不一一阐述 对于注释内容的空格，设置中提供的选项貌似无效，可以通过模板解决 当然，还存在着更多的 IDEA 操作细节，在之后的文章中会详解介绍。例如在分析容器源码时，如何快速的查看类的属性、方法、内部类信息等 对于学生，JetBrains 提供了 免费的授权许可证（对所有产品、所有版本生效） 申请地址：https://www.jetbrains.com/zh-cn/community/education/#students 国外的服务器访问速度存在较大的波动，常见的如 GitHub、JetBrains 等 JetBrains 的官网访问、加载需要耐心，当然，IDE 软件的下载速度是极快的，并不受影响。推荐计算机学习者，摸索科学上网的途径，尽可能的使用谷歌搜索等一系列生产力工具 以下为学生许可证的申请流程，每次颁发的许可证 有效期为一年，可续约 进入教育许可证申请主页，选择学生和教师的个人许可证申请界面 切换到第三个选项卡（OFFICIAL DOCUMENT 官方文件），该选项卡的信息会交由 人工进行审核 填写个人申请信息时，注意提交的证明材料，即官方文件，强烈建议选择为 学信网学籍报告，进入学信网个人主页，可以将学籍报告以 PDF 格式导出 填写完所有信息后，开始等待即可，若提交的为学信网个人学籍报告，则审核的速度和成功率都是极高的，切勿提交个人拍摄的学生证照片 当收到许可证申请通过的邮件后，根据邮件给出的链接来完成账号下的许可证绑定激活（可能存在问题） 当离开学校后，不再具备申请教育许可证的资格。当然，这时候的你，应当已经具备了独立维护开源项目的能力，可以选择申请 JetBrains 的开源许可证，这也是免费，过程不再做赘述 JetBrains 的全套产品许可证（个人），在不计算其它优惠的前提下，第一年为 1500 元左右，第三年为 800 元左右，一个在岗、转正的从业者，完全可以轻松负担 文档博客 每一位计算机的从业者，尤其是软件开发，都应当拥有一个长期、稳定维护的博客 可以这样说，Java 的生态极为庞大，若是只依靠个人的大脑记忆，是难以实现的。并且，反复的复习会造成时间的无意义空耗。更可怕的是，难以直观的认识自己，整理知识的碎片，越是往后，越是杂乱 以简单的 Linux 环境搭建为例，若不将其中的过程记录下来。在下一次搭建时，碰到的问题依旧需要浪费不必要的时间（互联网的解决方案参差不齐） 对于可以写作的平台与工具，我简单的做一下介绍（个人了解） MarkDown：每一位软件工程师都必须掌握的写作语法，为 GitHub 等一系列平台支持，它的重要性不言而喻 VSCode：非常适合写作的软件，支持原生的 MarkDown 语法。写作体验良好，插件也极为丰富，毕竟这是一款 代码编辑器，在性能也是表现极佳 GitBook、mdBook、VuePress：静态网站生成器，可以结合 GitHub Pages，快速的搭建自己的个人网站，但在样式上较为单调，定制化较难 语雀、掘金：博客写作平台。语雀的收录较差，但提供了良好的客户端软件；掘金的收录不错，其中的网页端编辑器也可以，或者选用 VSCode 做替代 这里提一嘴，不建议将 CSDN 选择为写作平台。确实，它可以为我们解决问题，也存在着极高的搜索引擎收录，写作体验也不错。这就跟百度搜索与谷歌搜索，可以解决问题，但在总体的效率上不值得 另外，也是最重要的两点，是我个人的一些感想 不要随意的粘贴、复制。若觉着自己对于某个问题的的理解不如当时参考的博客文章，请务必贴出链接，不必要追求原创 长期且稳定的维护。博客的记录极为烦恼，将自己当时烂熟于心的知识以大白话写出确实一时觉着无必要。长期撰写且定期整理维护 或深或浅、或短或长、或对或错，这都不影响博客的写作。本身并非是大佬的做法，也是小白及时巩固的手段 当然，只有吃透了一个知识点，再记录时才不会显得狼狈，可以在其中加入自己的理解。切勿学了点皮毛，就自认为拥有了大海 Hello，Java！ public class HelloJava { public static void main(String[] args){ System.out.println(\"你好，Java！\") } } 现在，开始简单的分析这段入门的 Java 代码（结构上的简单说明） public class HelloJava public 是访问权限修饰符的一种，公开的 class 类的标识，声明这是一个 Java 类 HelloJava 类名 Java 类中可以存在多个 Java 类，但只允许一个为公开类，即 public class Java 中的大小写区分严格，Hello 和 hello 指代的是两个不同的 Java 类 同时，Java 文件名必须与其中的公开 Java 类名称保持一致 public static void main(String[] args){} Java 的程序主入口函数，Java 虚拟机会从该入口开始执行程序代码 其中 static void 暂不做简述，记作静态、无返回值即可 main 是该函数的方法名，注意大小写 String[] args 作为字符串数组，存储程序指令，暂不必理会 主方法必须是公开的、静态的、无返回值的！ public static void 是不可更改的前缀，而 String[] args 也不建议改动 System.out.println() 打印内容到控制台并换行 . 调用、引用的意思，类、方法、属性之间的相互调用 ; 标识一行代码的结束 {} 标识一块代码的结束 小结 这一篇，不仅是 Java 的开发环境准备，其核心是介绍博客写作的必要性 暂时从 Rust 中脱开了身，已经忘了 Git 的推送是 pull 还是 push，Map 容器如何添加元素等 All work and no play makes Jack a dull boy. 短暂的放松自己，参考下其它语言的设计理念，会见到不一样的风景（被 Rust 暴揍了一顿，Java 真香） 读完了 Rust，才发觉虚拟机的自动回收与取消指针，究竟是多大的福音 任何事物的学习，都是需要长期的积累，偶尔的灵机一动，根植于雄厚的实践 惟愿风雨兼程，路尽仍显峥嵘！既然选择了远方，又怎么在意路边的风景？ 任何的行业，不存在热爱、毅力，走不了多远，只会在底部踌躇半生。至于与生的天赋、资源，可遇而不可求 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-08 11:44:27 "},"基础的编程概念/变量&常量.html":{"url":"基础的编程概念/变量&常量.html","title":"变量&常量","keywords":"","body":"变量的概念 变量，是存储在内存中的数据的形象化符号，可以方便开发者对于内存中数据的操作 int age = 12;，这是一个 Java 中的局部变量示例。它表示的是一个整数数字 12，变量名为 age。可以很清晰的理解，这个变量所代表的数据是年龄，形象化地表达出数据所代表的的含义 对于变量，它是存在内存空间中，名为 栈 的区域内，这一点暂不做赘述 变量的使用 对于变量的使用，需要注意 变量本身所在的作用域，大致分为全局作用域和局部作用域（此处仅作了解）。 注意，变量必须在初始化之后才可以被使用，即变量存在对应的内存中的数据，对于数据为 null 需要格外警惕（原始类型不允许为 null） int a = 10; System.out.println(a); 上述的示例，定义了变量 a，数据为整数 10，并打印在控制台。对于变量的更详细使用，将在之后提到，这里，无须在意其它 变量的命名 变量的命名是个大问题，我根据个人的理解标注出两点（极为重要） 根据变量所处的区域、性质，存在不同的 命名格式，例如局部、全局、常量 根据变量所指代的数据，必须做到 见名知意，仅通过变量名即可理解其代表的数据的作用 接下来，简单介绍变量的命名格式与如何做到见名知意（其余部分可参考案阿里代码规约） 局部变量的命名格式遵循 小驼峰原则（首单词的首字母小写），例如 userName、userPassword 首先，变量的命名 不允许以数字、下划线、美元符号为起始，尽可能的避免使用这三个元素 另外，Java 的变量 支持使用中文命名，但应当避免使用，可以将 英文无法解释的内容以中文的形式写在注释中 见名知意，就是 让变量的名称充分体现出其所代表的数据的作用。当然，将用户的名称数据使用变量名 age 指代，IDE 也不会做纠正，但这会造成不必要的误会。同时，也尽可能的避免使用 a、b、aa 这些无意义的命名 小驼峰命名、纯英文字母、有意义命名，这是对于局部变量命名的介绍。之后的全局变量、常量、类名、方法名等也大同小异，同样参考阿里规范 变量的不可变性 Java 中的变量，默认为可变变量。若是需要使得变量具备不可变性，则需要在变量名之前追加 关键字 final 做前缀修饰。不可变的变量，可以称作常量 final，意为不可变、最终的，若变量前缀了 final 修饰符，则必须使得 变量的定义与数据初始化同步进行，至少在局部变量中应如此 /* 正确 */ final int a = 10; /* 正确 */ final int b; b = 20; /* 错误，final 变量仅可以被赋值一次 */ final int c = 30; c = 30; 被定义为不可变的变量，在使用中，仅可以被赋值一次。所以，尽可能的做到定义与赋值的同步，也易于理解。常量通常表示某个不可变的数据，例如一天中存在几个小时 对于常量，它大多是定义在全局，作为类的属性存在，它的命名规则为：字母全部大写，单词之间以下划线分隔 值得注意的我是，对于常量的命名，不建议做任何的缩写，尽可能的表达出常量数据的含义。而对于默认的变量，大多使用完即释放，则可以做一定的简写 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 08:58:47 "},"基础的编程概念/注释.html":{"url":"基础的编程概念/注释.html","title":"注释","keywords":"","body":"注释的概念 对于注释，它可以使得部分内容对计算机不可见，即不会被作为代码进行编译 那么，注释内容的实际服务对象，就是开发者，是人，良好的注释习惯，是团队合作的必然 对于个人，注释可以使得自己快速的回想起该部分代码的功能定位；对于其他人，通过注释，也可以快速的接手项目，做二次开发、维护 类似于博客，注释是对于代码的备注。人的大脑终究是狭小的，良好的注释风格必不可少！ 注释的形式 在 Java 中，注释存在三种形式，分别为单行注释、多行注释、文档注释 对于单行注释 // 对单行内容进行注释，用于方法体内，该行自 // 以后的内容被注释 对于多行注释 /* */ 对多行内容进行注释，用于方法体内，在 / / 中的所有内容被注释 对于文档注释 /** */ 用于类、属性和方法的注释，主要记录方法、类的特点或信息 可以生成 HTML 格式的 JavaDoc 说明文档，类似于 Java 官方 API 手册 对于这三种，分别存在不同的应用场景。而单行、多行注释则较为接近，当内容过多时，可以使用多行注释替代单行注释（切勿使用文档注释，这不规范） 注释的使用，应当将注释符号与注释内容保持一个空格，但 IDEA 中的注释生成无法解决，建议使用代码模板定义该风格的注释 注释的应用 以下，介绍 Java 中的三种注释的使用，部分代码摘自 JDK 源码，暂无须理解，仅作示例使用 对于单行注释、多行注释，很好理解，就是运用于方法体内，做一定的解释作用 // ArrayList can be subclassed and given arbitrary behavior, but we can // still deal with the common case where o is ArrayList precisely // 数组列表可以被子类化，也可以被赋予任意的行为 // 但我们仍然可以处理通常的情况 o 就是数组列表 /* 数组列表可以被子类化，也可以被赋予任意的行为 但我们仍然可以处理通常的情况 o 就是数组列表 */ boolean equal = (o.getClass() == ArrayList.class) ? equalsArrayList((ArrayList) o) : equalsRange((List) o, 0, size); } 上述的 equals 变量，较为复杂，可以通过单行、多行注释做解释说明。若是需要注释的内容过多，致使单行注释极长，可以考虑使用多个单行注释或一个多行注释做替代，更好的阅读体验 简单的说，当单行所需注释的内容过多，可以考虑多行注释作为替代 紧接着，开始介绍一直较为特殊的注释，文档注释 /** * Default initial capacity. * 默认初始容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Returns the number of elements in this list. * 返回此列表中的元素数量。 * * @return the number of elements in this list * @return 这个列表中的元素个数 */ /* * 1 * 2 */ public int size() { return size; } 上面的两份示例，介绍了文档注释的使用。文档注释，应用于类、类的属性、类的方法上，对其做说明做用 在使用 Java 的 API 手册查询时，可以发现，它可以提供某个类方法的作用、传入参数、返回类型等。这些，都是基于文档注释完成的 在示例中，@return 之后，就是对于方法返回值的描述。对应的文档注释参数还有很多，这里不再赘述 通过特定的命令，可以将 Java 程序中的文档注释抽离，制作成 API 说明手册。大多情况下，考虑的是使用第三方技术制作程序说明手册 小结 注释的使用，告一段落。主要是介绍三种注释的形式及其应用的场景 其中的文档注释，较为特殊，单行、多行注释是做互补作用。另外，也存在一些特殊的注释参数 TODO：功能待实现 FIXME：功能待修正 XXX：功能待改进 三个特殊的注释关键字，可以被 IDE 捕捉、显示，方便程序的维护、管理 有一点需要注意，注释的内容可以看似执行，这违反了之前的注释铁律：注释的内容对计算机不可见 例如 // \\u000a 注释内容被换行，其中的注释内容会被解析，但 IDE 事先不会发现该问题，这涉及到了字符集编码的问题，暂不做介绍 注释的内容，应当言简意骇，必要的语言精炼可以缩短阅读的时间 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:28:29 "},"基础的编程概念/原始类型.html":{"url":"基础的编程概念/原始类型.html","title":"原始类型","keywords":"","body":"原始数据类型 在之前，提到了变量是用于指代内存中存储的数据。而数据，也必然存在类型，以便于管理 Java 中，数据类型分为两类，原始类型、引用类型，其中原始类型存在四类八种，其余的数据类型则统一视为引用类型 下述格式：中文名称 英文名称 内存存储（一字节八位二进制） 类型默认值 整数类型 类型 名称 字节 默认值 字节型 byte 1 0 短整型 short 2 0 整 型 int 4 0 长整型 long 8 0L 浮点类型 类型 名称 字节 默认值 单精度 float 4 0.0F 双精度 double 8 0.0D 布尔类型 类型 名称 字节 默认值 布尔 boolean 存在争议 false 字符类型 类型 名称 字节 默认值 字符类型 char 2 '\\u0000' 这八个数据类型，存在着各自的细节，这里简单介绍布尔、字符 对于布尔，它的实际占用内存大小，并不确定，当它作为数组元素或单个变量时，具备着不同大小的字节 对于字符，它的赋值是使用单引号''，而非双引号 “”。并且，字符类型可以接收整数，再转换为对应的字符 char a = 122; char b = 'z'; System.out.println(a); System.out.println(b); 对于数据类型，更多的细节，可以参考 JVM 虚拟机规范第二章（不建议在初学时深入） 字面量与细节 字面量，指的是：变量直接接收的数据，不经由其它变量。例如 int a = 10;，而 int b = a; 则不再是字面量 整数字面常量，其默认类型为 int；浮点数字面常量，其默认类型为 double int a = Integer.MAX_VALUE; long b = a + a; long c = Integer.MAX_VALUE * 2L; System.out.println(b); System.out.println(c); 在 long 类型变量接收两倍的 int 最大值时。若接收的是字面值，则需要强制转换，在 IDE 中会出现提示，这涉及到了类型转换 只需要知道，long 接收超出 int 最大值的整数时，必须后缀 L 对于浮点型，也是如此，但追加的后缀是 F，因为实际默认值是 Double，大于 Float Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-05 20:12:45 "},"基础的编程概念/类型转换.html":{"url":"基础的编程概念/类型转换.html","title":"类型转换","keywords":"","body":"类型转换 彼此兼容的类型之间，可以相互转换，兼容类型的大小比较则根据其内存空间判断 自动隐式 转换：无须声明，例如 int 类型变量接收 byte 类型变量 强制显式 转换：需要声明，例如 byte 类型变量接收 int 类型变量 对于原始数据类型之间的转换，需要注意参与其中的是 变量，还是字面量 对于字面量 以整数为例，其默认的字面量的类型是 int，此时以一个 byte 接收整数字面量 byte a = 100; 此时，发生的是自动隐式转换，100 未超出 byte 的取值，可以由 int 类型转为 byte 类型 但是，若 byte 接收的整数字面量超出了取值范围，例如 byte a = 200; 此刻，产生的就是强制显式转换，需要手动声明转换的类型 byte a = (byte) 200; 简单的理解为，当 byte 接收一个兼容类型的整数字面量时，存在两种情况 未超出 byte 的取值：整数字面量由 int 自动隐式转换为 byte byte a = 100; 已超出 byte 的取值：必须进行显式的强制转换 byte b = (byte) 200; 基于字面量在类型转换中的表现，需要注意一个问题 字面量默认 int 类型，若 long 类型变量接收了超出 int、小于 long 的整数字面量，必须后缀 L，提升该整数字面量的类型为 long 对于变量 在变量的数据类型转换中，则无须在意整型、浮点型的默认字面量类型 任何不同类型的变量之间，由大向小转换，都必须强制声明、强制转换 int a = 100; byte b = (byte) a; int 是三十二位二进制，byte 是八位二进制，转换的时候必然产生影响 数据溢出 在强制类型转换中，会导致一些令人疑惑的问题，这称为 数据溢出 最简单的例子就是，byte a = 400; 整数字面值的默认类型是 int，且赋值的字面量超出 byte 取值，无法自动转换 此刻，会发生如下情况 先理解四个概念 符号位：二进制中，最高位作为符号位存在，0 为正，1 为负 原码：数据的直接二进制表示，以十进制 127 为例，目标为八位二进制 + 127：01111111 原码 - 127：11111111 原码 反码：在原码的基础上，全部取反，包括最高符号位 + 127：10000000 原码 -> 取反 - 127：00000000 原码 -> 取反 补码：在反码的基础上，二进制数 加 1 + 127：10000001 取反 -> 补码 - 127：00000001 取反 -> 补码 数据溢出问题，是由二进制截断、符号位、原码、反码、补码组成 简单的理解：负数的二进制表现，是其对应正数的补码 正数的二进制，就是它的原码表现形式 负数的二进制，则是它对应的正数的补码表现形式 强制转换的最终结果，以字节型为例，它由八位二进制组成 若接收的数据的二进制表现已超出八位时，则对超出部分进行截断（注意最高位符号位） 此处，需要注意最高位，即符号位，正数可能在截断后转为负数，这也是为什么正数溢出后，会出现负数的原因 若二进制符号位为 0，则直接按原码，求出结果 若二进制符号位为 1，则当作补码，反推回原码，根据对应的正数，求出负数结果 负数的真正二进制表现，是其对应正数的补码表现 byte b = (byte) 400; System.out.println(b); /* b 的最终结果为 -112 b 的二进制体现：110010000 截断为八位二进制：110010000 -> 10010000 112 的原码表现：01110000（八位二进制） 112 的补码表现：01110000 -> 取反 10001111 -> 补码 10010000 可以看出 + 112 的补码 = - 122 的原码 */ 小结 值得注意的是，浮点型中，存在精度的概念，double 字面量无法向下自动隐式转为 float 红色实线：内存存储自小向大转换，无损失，自动转换 蓝色虚线：内存存储自大向小转换，精度损失，强制转换 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-05 20:20:57 "},"基础的编程概念/运算符.html":{"url":"基础的编程概念/运算符.html","title":"运算符","keywords":"","body":"算数运算符 加号、减号、乘号（+、-、*） 相当于数学中的 +、-、* 除号（/） 整型相除，只保留整数，其余舍弃 整型、浮点型相除，保留小数 取余（%） 整型取余，结果为整数表现 整型、浮点型取余，结果为浮点数表现 自增、自减（++、--） 若 位于左侧，先进行变量本身的运算 若 位于右侧，先参与表达式的运算中 逻辑运算符 逻辑与、或、非（&、|、！） 与：表达式结果 都为 true，则结果为 true 或：表达式结果 都为 false，则结果为 false 非：对表达式的 结果取反 短路与、或（&&、||） 当 左侧表达式可以得出结果，则右侧直接跳过，不再参与运算 短路的内容不参与运算，不代表不参与编译，依旧会抛出异常 逻辑与、或、非，又可以称为 位与、位或、位非 位运算符 若 参与比较的不是布尔值，而是 实际的数值，则它与短路与、或、非存在差异 位与、或、非，是对应的二进制位进行比较，注意正、负数的按位非 按位与 &：对应的二进制 同时为 1 则为 1，否则为 0 按位或 |：对应的二进制 同时为 0 则为 0，否则为 1 按位非 ~：对应的二进制 0 为 1，1 为 0 按位异或 ^：对应的二进制 相同为 1，不同为 0 // 按位与 `&`：同时为 1 则为 1，否则为 0 System.out.println(12 & 3); /* 12：00001100 3 ：00000011 ------------ ：00000000 12 & 3 的结果：0 */ System.out.println(13 & 4); /* 13：00001101 4 ：00000100 ------------ ：00000100 13 & 4 的结果：4 */ // 按位或 `|`：同时为 0 则为 0，否则为 1 System.out.println(14 | 3); /* 14：00001110 3 ：00000011 ------------ ：00001111 14 | 3 的结果：15 */ // 按位非 `~`：0 为 1，1 为 0 System.out.println(~3); /* 3 ：00000000 00000000 00000000 00000011 ------------ 运算结果：11111111 11111111 11111111 11111100 二进制的负数形式，可以先逆转为对应的正数，再得出实际的负数 正数结果：00000000 00000000 00000000 00000100 (+ 4) 实际结果： - 4 ~3 的结果：-4 */ // 按位异或 `^`：相同为 0，不同为 1 System.out.println(7 ^ 3); /* 7 ：00000000 00000000 00000000 00000111 3 ：00000000 00000000 00000000 00000011 ------------ ：00000000 00000000 00000000 00000100 7^3 的结果：4 System.out.println(16 ^ 7); // 原码 16：00000000 00000000 00000000 00010000 // 原码 7：00000000 00000000 00000000 00000111 // 按位异或：00000000 00000000 00000000 00010111 */ 位移运算符 左移 二进制符号位向左移动，低位补 零 右移 >> 二进制符号位向右移动，正数高位补 零，负数高位补 一 无符号右移 >>> 二进制符号位向右移动，正、负数高位补 零 // 左移 System.out.println(10 > 2); /* 10 的二进制：00001010 右移两位 ：00000010 10 右移两位：2 */ // 无符号右移 System.out.println(-3 >>> 2); /* 3 的二进制：00000000 00000000 00000000 00000011 （正 3 的原码） -3 的二进制：11111111 11111111 11111111 11111101 （正 3 的补码） -3 无符号右移两位：00111111 11111111 11111111 11111111 （正 3 的补码右移两位，高位补 零） -3 >>> 2 的结果：00111111 11111111 11111111 11111111 (+ 1073741823) 得出，负数的无符号右移，相当于对应正数的补码右移，高位补零 */ 值得注意的是，整数字面值默认 int，是四字节三十二位的二进制 若负数的无符号右移出现数值极大的情况，注意当前数值类型的内存字节，对应的二进制位数 三目运算符 写法：表达式 ? 满足条件分支 1 : 不满足条件分支 2 可以嵌套使用，但为了可读性，不建议频繁使用 运算符存在执行的优先级，大多时候可以使用 () 修改、控制 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-05 20:24:09 "},"基础的编程概念/流程控制.html":{"url":"基础的编程概念/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 条件执行 for while 循环执行 while do while 分为 条件执行 和 循环控制 两类 条件执行：当 某一分支满足条件时，执行该分支 if - else if ... - else switch case：条件分支 case 末尾追加 break 关键字，保证正常退出 7.0 及以后，可以接收 byte、short、int、char、enum、String 循环控制：循环代码块，直至条件语句不满足 for i for each：无需下标索引，即可遍历元素 while do while：先执行一次循环，再判断条件是否满足 循环退出：通过关键字，控制循环的结束 break：退出当前循环；可以增加标签，指定退出循环的层数 continue：结束本次循环，但不退出当前循环 切勿将 return 关键字看作循环退出 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-05 20:31:42 "},"基础的编程概念/数组.html":{"url":"基础的编程概念/数组.html","title":"数组","keywords":"","body":"数组概念 数组：同种数据类型 组成的、固定长度 的、内存中 连续存放 的若干条数据 数组是引用数据类型，引用数据类型必须通过关键字 new 创建 数组的声明分为三种，以 int 数组作为示例 /* 确定数组长度，声明与赋值分离 */ int[] array1 = new int[3]; /* 声明并赋值，通过赋值的数据确定数组的长度 */ int[] array2 = new int[]{1, 2, 3}; /* 写法上，相较于第二种，更为简洁 */ int[] array3 = {1, 2, 3}; 数组的类型、长度一旦确定，则不可更改，这需要与其它语言中的数组区分开 多维数组 数组中，存在一维数组、二维数组等等，二维以上的数组，统称为多维数组 本质上，多维数组依旧可以看作是一维数组 简单的理解为，一维数组中的三个元素，是三个数组，将数组类型作为数组内的元素 栈堆分析 数组存储的内存分析：栈堆内存分析 数组是引用类型，内存中的存储方式与原始类型不同 简单的理解为，数组有两块内存空间，分别存在于栈、堆 栈内存：存放堆内存的实际引用地址 堆内存：存放实际的数据 原始类型的变量名、数据内容都是存放在栈内存中 引用类型的实际数据是存放在堆内存中，由变量名指向 上述图片引用自 Rust 可以看出，数组的数据是存放在堆内存中的（第二块图），变量名指向实际的堆内存地址 当同种类型、不同长度的数组相互赋值时，仅需要 更改指向地址即可 当一块 堆内存不再被栈内存指向，则该内存会被自动释放，由虚拟机负责回收 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-05 22:22:02 "},"基础的编程概念/函数.html":{"url":"基础的编程概念/函数.html","title":"函数","keywords":"","body":"方法的组成 函数，也可以称作方法：用于抽取、封装某一段功能代码 public static void main(String[] args) { } 修饰符 返回值 函数名（参数列表） { 函数体 } 一个标准的函数由以下几个部分组成 修饰符：表示不同的目的，例如 public、static 返回值类型：声明该函数的返回值类型，可以不存在返回值，写作 void 函数名：函数的名称 参数列表：声明该函数调用时可以接收的参数，可以是原始类型、引用类型 函数体：函数中具体的代码块 返回值：函数执行后产生的结果 方法的参数传递 在函数的调用过程中，可以同时传入若干个任意类型的参数 对于传入的参数，也分为原始类型、引用类型两类 整数、浮点数、字符，或者引用类型的数组、自定义类，都是可以的 值得注意的是，在 Java 中，函数的参数传递，只存在值传递 值传递：参数传递时，形参接收的是实参的实际数据的拷贝副本 引用传递：参数传递时，形参接收的是实参的引用地址的拷贝副本 Java 的参数传递极易混淆，而 Java 官方已经定义，Java 中只存在值传递 Java 就是值传递，只不过是将对象的引用当做值传递给方法，即值传递中的按引用传递 值传递示例（原始类型）： public static void main(String[] args) { int a = 10; int b = 20; set(a, b); System.out.println(\"=====\"); System.out.println(a); System.out.println(b); /* 20、10、=====、10、20 */ } public static void set(int a, int b) { a = 20; b = 10; System.out.println(a); System.out.println(b); } 值传递示例（引用类型）： public static void main(String[] args) { int[] ints = {1, 2}; System.out.println(Arrays.toString(ints)); set(ints); System.out.println(Arrays.toString(ints)); /* [1, 2]、[2, 2] */ } public static void set(int[] array) { array[0] = 2; } 在上述的两个示例中，原始类型的传参，实际参数不受形参变化的影响，不做考虑 而对于引用参数的传递，形参的修改，实参也随之修改，看似不符合值传递的定义 当传递的是引用类型，拷贝的副本是对象的引用地址 简单的理解，形参得到实参的拷贝副本，间接的获得引用地址，可以修改堆内存的数据 值传递的引用类型，在此刻，与引用传递十分相似 不同的是，真正的引用传递，形参是直接获得引用地址，并可以对该地址做出修改 上图，是关于值传递、引用传递的简单说明，真正意义上的引用传递，可以参考 Rust 语言，讲述清晰 在值传递中，引用对象 2 获得的仅仅是堆内存地址的拷贝副本，只存在访问、修改堆内存数据的权限 而在引用传递中，引用对象 2 直接获得了堆内存的 root 权限，可以直接修改其引用地址 姑且，将值传递再细分为按值传递、按引用传递 只需要牢记两点 值传递，形参尽可以修改内容 引用传递，形参可以修改引用地址 在 Java 中，只存在值传递，且传递的是引用地址的拷贝，仅可以操作内存数据 方法的可变长参数 当函数的 传入参数数目不确定 时，可以使用 可变长参数 进行定义，例如排序方法 以下代码是关乎可变长参数的使用案例 public static void main(String[] args) { get(12, 12, 23, 34, 45, 34, 23); } public static void get(int... a) { System.out.println(Arrays.toString(a)); } 对于可变长参数的使用，需要注意两点： 可变长参数必须放在参数列表的末位 一个函数的参数列表，仅可以存在一个可变长参数 方法的可变长参数，实质上就是数组的体现，建议使用数组对象进行传参，也更易于理解 public void get(int[] a, String[] b) {} 函数的参数列表中，两个 不同类型的可变长参数也不可以共存，而数组可以做到 方法的重载 当类中，存在多个同名方法时，这就是方法重载的体现 函数重载：重载仅是 方法名的相同，参数列表、访问修饰符、返回值类型可以不同 以下是方法重载的代码示例 public static void main(String[] args) { get((byte) 1); Integer integer = get((short) 1); get(1); get((long) 1); } private static void get(byte... a) { System.out.println(\"byte\"); } public static Integer get(short... a) { System.out.println(\"short\"); return 0; } public static void get(int... a) { System.out.println(\"int\"); } public static void get(long... a) { System.out.println(\"long\"); } 值得注意的是，不可以存在参数列表相同的重载函数 简单的理解，函数名同名，参数列表不同 方法的递归调用 递归函数，简单的理解，就是自己调用自己的函数 下列是函数的递归调用，求阶乘 public static void main(String[] args) { System.out.println(get(5)); } public static int get(int a) { if (a == 0) { return 1; } else { return a * get(a - 1); } } 步骤如下 get(5) = 5 * get(4) get(4) = 4 * get(3) get(3) = 3 * get(2) get(2) = 2 * get(1) get(1) = 1 * get(0) get(0) = 1 计算得出，get(5) 的最终结果为 120 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:36:59 "},"面向对象的思想/类的基础.html":{"url":"面向对象的思想/类的基础.html","title":"类的基础","keywords":"","body":"类的组成 面向对象是一种编程思想，而 Java 的设计则很好的诠释了这一概念 一个类由属性、方法两部分组成 类变量：类本身具有的属性 类方法：类本身具有的方法 实例变量：类的对象具有的属性 实例方法：类的对象具有的方法 类变量、实例变量可以统称 成员变量，而类变量也可以称作 静态变量、静态成员变量 类方法、实例方法可以统称 成员方法，而类方法也可以称作 静态方法、静态成员方法 简单理解为，类属性、类方法是类本身所具有的；实例属性、实例方法依赖于类的对象 类的组成部分 示例 public class Person { /* 类变量 */ private static String name; /* 实例变量 */ private Integer age; /* 类方法 */ public static void eat(String food) { } /* 实例方法 */ public void sing(String sing) { } } 成员变量与局部变量 类的成员变量与方法的局部变量存在区别 书写位置：成员变量位于类中、方法体外；局部变量位于方法体、代码块中 内存位置：成员变量位于堆内存；局部变量位于栈内存 类型默认值：成员变量存在默认初始值；局部变量不存在 作用域：成员变量作用域整个类；局部变量只在方法体、代码块中有效 生命周期：成员变量自类、对象的创建到销毁；局部变量随着方法、代码块的执行完毕而结束 类的实例对象 类在实例化之后，可以得到该类的对象，称为实例对象，实例化的关键字是 new Animal animal = new Animal(); new 在堆内存中，为实例对象开辟 新的存储空间，需要格外注意 当一个类实例化之后，其中的实例变量、实例方法才可以被调用 而对于静态成员变量、方法，则无需类的实例化，区别在于关键字 static 被 static 声明的属性、方法，在类加载时创建，属于类本身，由所有实例对象共享 类在实例化以后，可以获得一个该类的对象，并操作其中的实例属性、实例方法 类的构造方法 在类中，存在一个特殊的方法，构造方法 构造方法存在以下几点 构造方法名与类名保持一致 构造方法不存在返回值，也不应该有返回值 Java默认提供无参的构造方法，若重载了有参构造，则不再提供 构造方法可以私有化，应用于特定的场景 需要注意的一点，若重载了构造方法，必须手动声明无参构造 this 关键字 this 关键字指代当前实例对象，存在三种用法 this. 属性名：指代当前的实例属性，见于构造方法的重载 this. 方法名：指代当前的实例方法 this()：用于构造方法中，调用其它的构造方法，置于构造方法首行 static 关键字 static 关键字用于修饰类变量、类方法、代码块以及内部类，意为 静态 静态的属性、方法，在类加载时一并创建，优先级高于实例对象的属性、方法 简单的说，静态属性、方法不能访问非静态的属性、方法，反之则可以访问 静态的属性在类加载时即初始化，该类所有的实例对象则共享一份静态属性 静态代码块存在于类中，在类加载时执行，仅执行一次 简单的理解为，static 修饰的类属性优先创建，被多个实例对象所共享使用，数据唯一 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:47:12 "},"面向对象的思想/类的封装.html":{"url":"面向对象的思想/类的封装.html","title":"类的封装","keywords":"","body":"类的封装 类的三大特性，封装、继承、多态，其中，实现封装的关键字是 private Java中，类的封装只有一个目的：隐藏内部实现细节，提供功能实现 对于内部，类的属性访问、修改不可直接进行，而是通过特定的方法 get、set 对于外部，只需要在意该类可以提供的功能，而不必要关心其内部细节 喜欢吃鸡蛋，而不必在意鸡是下蛋的细节，这是封装的理解 访问权限修饰符 Java 中的四个关键字 private、default、protected、public，作为访问权限修饰符存在 作用于类、属性、方法，代表着不同的可访问级别，具体的细节如下 以上，是详细的访问级别，当不添加访问修饰符时，默认为 default 对于 Java 中的 package 包，简单理解为文件夹即可，代表 Java 源文件存放的层次目录 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:47:51 "},"面向对象的思想/类的继承.html":{"url":"面向对象的思想/类的继承.html","title":"类的继承","keywords":"","body":"类的继承 Java 中，实现继承的关键字是 extends 在继承中，存在几个注意点 Java 只支持单继承，即一个子类只可以继承一个父类 子类可以继承父类的（非私有）属性、（非有参构造）方法 子类自动调用父类的默认无参构造 根父类 Object() 在 Java 的继承体系中，存在一个最高父类 Object，由它派生出其它的 Java 类 Object 类中，定义了一系列的公用方法，常见的有 toString()：返回该对象的字符串表示 equals()：比较两个对象的相等 hashCode()：返回该对象的哈希值 clone()：对象的克隆 ==、equals() 的区别 在 Java 中，两个数据元素是否相同，存在两个方法判断，==、equals() == ：对 原始 类型进行 值 判断，而 引用 类型则通过 堆存储地址 判断 equals() ：不可以用于 原始 类型判断，引用 类型则通过 堆存储地址 判断 简单的理解，== 对于原始类型，就是比较内容上的是否相同 而对于引用类型，==、equals() 则是比较两个变量的对象引用地址是否相同 值得注意的是，equals() 可以被重写，更改它的判断条件，多见于 String、Integer Java 中不支持 运算符重载，所以 == 的定义不会改变 方法的重写 方法重写的前提，是父类方法可以被子类继承 在 Java 的继承，子类可以在继承父类方法的基础上，重写该方法，存在以下限制 子类不可以重写父类的静态成员方法、默认构造方法，但可以存在同名静态方法 方法重写时，必须使用 @Override 注解进行声明，这是一个有效的方法重写 属性不存在重写！！！ 父类静态方法可以继承、不可重写，但允许存在同名静态方法，参考之后的 多态 @Override 注解可以对方法的重写做出约束（了解即可） 子类重写方法的访问权限，大于、等于父类方法 子类重写方法的返回类型，是父类返回类型或其子类 子类重写方法抛出的异常，是父类抛出的异常类型或其子类 方法重写的约束，也可以满足里氏代换的要求 方法的重写与方法的重载只是看似一样，实质完全不同的两个概念 super 关键字 super 关键字可以访问父类的构造方法、实例属性、实例方法 简单的理解为，子类继承了父类，父类相当于实例化了一个对象 基于此，可知 super 关键字的两个用途 在子类的构造方法中，调用父类的构造方法 访问父类的（非静态、私有）属性、（非静态、私有）方法 super 关键字与 this 关键字 都必须置于构造方法首行，率先执行，故二者又不可同时存在 final 关键字 最早见到 final，是在常量中，表示 final 常量，定义变量的不可变性 值得注意的是，final 关键字的用法很多，但含义上是一致的 在继承中，final 又意为不可继承 若 final 修饰类，则该类不可被继承；若 final 修饰类实例方法，则该方法不可被重写 值得注意的是（多次提醒），static 是可继承、不可重写，但可存在静态同名属性、函数 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:48:21 "},"面向对象的思想/类的多态.html":{"url":"面向对象的思想/类的多态.html","title":"类的多态","keywords":"","body":"类的多态 多态：一种类型声明的的变量，可以引用多种实际类型对象 多态的实现存在三个前提（不满足则不构成类的多态） 继承：子类继承父类属性、方法 方法重写：子类重写父类方法 向上转型：子类实例对象赋值给父类引用变量 子类实例对象：new Son(); 父类引用变量：Father father; 简单的说，子类重写了父类的实例方法，且子类对象赋值给了父类变量，这就是类的多态、多种形态 类的多态中，分为两个重要的点（务必注意，多态理解的核心） 多态的向上、向下转型 多态的静态、动态绑定 多态的向上转型 多态的向上转型：当子类实例变量赋值给父类引用变量 Father father = new Son(); 多态的向上转型：（构成多态） 父类引用变量可以调用子类重写的父类方法 父类引用变量不可以调用子类中独有的方法 多态的向下转型 多态的向下转型：将向上转型的父类引用变量再强转会子类引用变量 Son son = (Son) father; 多态的向下转型，实质就是转换为原来的类型，向下转型之后不构成 类的多态 多态的向下转型：（不构成多态） 必须以多态的向上转型为前提条件（先向下，再向上） 在向下转型的过程中必须是 强制类型转换 为了避免类型转换异常，可以通过关键字 instanceof 判断 多态向下转型后，子类引用变量可以 调用子类特有的方法 instanceof 关键字用于比较两个类是否存在继承关系 多态的静态绑定 静态绑定：在程序编译时确定的方法（子类无法重写的父类静态方法） 编译时类型 变量 = new 运行时类型(); 简单的理解，根据子类是否存在，父类的同名静态方法 若子类存在同名静态方法，调用子类实现（就近原则，以 new 的实例对象为准） 若子类不存在同名静态方法，调用父类实现 多态的动态绑定 动态绑定：在程序运行时确定的属性、方法，以右侧运行时类型为准 静态绑定针对的是 static 类属性，而动态则是实例属性、实例方法 当多态向上转型的父类引用变量，调用父类、子类中同名的属性、方法时，实际调用的是子类重写的父类方法（实例属性、实例方法） 简单的理解，一个类重写了 toString()，再通过该类对象调用，则不再是 Object 子类重写了父类的实例方法，且在右侧实例对象是子类时，则调用子类的实现 继承中的执行顺序 在 Java 的继承中，父类、子类的各种属性、方法、代码块，存在不同的执行优先级 若属性、方法、代码块的优先级相同，则顺序执行 父类静态字段、静态代码块 子类静态字段、静态代码块 父类成员变量、非静态代码块 父类构造方法 子类成员变量、非静态代码块 子类构造器 简单的理解，父类、子类的静态部分是第一优先级，其次是父类其他部分、最后是子类 值得注意的是，构造方法的执行优先级，低于实例属性、方法 这也是为了方便 通过构造方法，为对象的实例属性赋值 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:48:44 "},"面向对象的思想/抽象&接口.html":{"url":"面向对象的思想/抽象&接口.html","title":"抽象类","keywords":"","body":"抽象的概念 Java 中的抽象存在两个体现，抽象类、抽象方法 抽象类： 抽象存在的类，现实中找不到该类的实际存在（概念存在） 抽象方法： 存在于抽象类中的方法，不存在方法体 抽象类 的语法结构：public abstract class 类名 {} 抽象方法 的语法结构：public abstract 方法名 (); 抽象类的理解，可以参考 白马非马 动物是抽象的概念，相对于它，马是具体的概念 马是抽象的概念，相对于它，白马是具体的概念 基于 白马非马，抽象类的第一特征： 抽象类无法实例化对象 然而，抽象类可以被普通类继承，基于 类的继承： 抽象类存在构造方法 抽象类定义的方法为所有子类共有， 抽象子类必须重写抽象类定义的所有抽象方法 但是，当 子类也为抽象类 时，则无需重写 抽象方法重写的意义在于，子类的的同一方法具有不同的实现，无法由父类统一 抽象类主要是用于 定义公共的模板，相当于一种规范，对于子类的规范， 抽象方法则是抽象类定义的规范的组成部分 简单的理解，抽象类定义了实现的模板，而继承的 子类则对其内容加以实现 值得注意的是： 抽象类中可以存在非抽象方法，而抽象方法所在的类则必须是抽象类 抽象方法必须被抽象子类重写，所以 抽象方法不可使用 private 接口的概念 接口的出现，弥补 Java 中不可以多继承 的问题，一个类可以实现多个接口 简单的理解，接口是基于抽象的增强，且为 Java 实现了 “多继承” 接口类 的语法结构：public interface class 类名 {} 接口与抽象，存在相同，也存在不同，需要仔细鉴别 接口存在一些需要注意的地方，相对于抽象类 定义接口的关键字是 interface ，位于类名之前 实现接口的关键字是 implements ，implements 排在 extends 后面 接口是被其它 Java 类 实现 而非 继承，不可以实例化的同时，也不存在构造方法 接口中定义的抽象方法，也必须被实现类重写 若接口类作为方法的形参，则传入的实参可以是实现该接口的子类对象 对于接口类、接口方法，存在 默认的前缀修饰符 接口中的成员属性：默认修饰符 public static final，全局、静态、常量 接口中的成员方法：默认修饰符 public abstract，公共、抽象 在接口类中，可以定义存在方法体的普通方法 接口类可以定义 static 静态非抽象方法，存在方法体 接口类可以定义 default 默认非抽象方法，存在方法体 抽象与接口的理解 可以看到，抽象与接口都存在关键字 abstract，且不与 static、final、private 共存 核心在于，abstract 抽象方法，必须被子类在继承的前提下，进行方法的重写 抽象和接口看似相同，但实际上，二者的定位是有区分的 简单的理解，抽象类是抽取某个群体中的共有方法，而接口则是代表其中某些个体所具备的独有方法 以鸟这个抽象的概念为例（切勿较真，只作举例） 鸟会飞，所以的鸟都会飞 ---> 抽象类则定义了 “飞” 这个抽象方法（公有） 企鹅也是鸟类，但企鹅会游泳 ---> 接口类则定义了“游泳” 这个接口方法（独有） 一个类在具备共有方法的同时，也存在着多个特有方法 单继承：继承共有方法，抽象类、普通类定义子类共有 多实现：实现特有方法，接口定义子类特有 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:49:26 "},"面向对象的思想/内部类.html":{"url":"面向对象的思想/内部类.html","title":"内部类","keywords":"","body":"内部类的概念 内部类：理解为定义在类中的类 外部类：包含内部类的类 内部类 只是 编译时概念，编译后会作为独立的字节码文件存在 内部类大致划分为三类 成员内部类 ---> 静态成员内部类、非静态成员内部类 方法内部类 匿名内部类 静态成员内部类 静态成员内部类：定义在类中、方法体外，采用关键字 static 静态成员内部类 的语法结构：public static class(){} 与独立的 Java 类一样，它可以存在 静态变量、方法，成员变量、方法以及构造方法 静态成员内部类 只可以访问外部类的静态成员 若在 静态成员内部类 中访问外部类的同名静态成员 外部类名. 静态成员名 若需要创建 静态成员内部类 的对象 外部类名. 内部类名 对象名 = new 外部类名. 内部类名 (); 非静态成员内部类 与 静态成员内部类 相比，非静态成员内部类 没有定义关键字 static 非静态成员内部类 的语法结构：public class(){} 非静态成员内部类 不可以拥有静态的属性、方法，例如 main方法、构造方法 非静态成员内部类 不可以访问外部类的静态属性、方法 外部类在访问 非静态成员内部类 的实例属性、方法时，必须通过它的实例对象 new 内部类 (). 属性 / 方法 若内部类需要指定访问外部类的成员变量，this 指代内部类对象 外部类. this. 成员变量 若需要直接创建 非静态成员内部类，则必须先创建外部类对象 外部类. 内部类 对象 = new 外部类. 内部类 值得注意的是 非静态成员内部类 中，不存在静态相关的属性、代码块 外部类中的静态方法、代码块也不能访问和使用 非静态成员内部类 理解了 static 静态 与 实例属性、方法，就明白了静态、非静态成员内部类的差异 局部内部类 局部内部类 是定义在方法体中的类，作用范围仅限于当前方法 class 类名 {} public class Demo{ class Person{ // 内部类 Person } } 局部内部类 的使用存在以下几点 局部内部类 的类名不可使用 关键字 static、public 等修饰 被 局部内部类 中的方法所访问的外部方法的局部变量，已经由Java编译器默认前缀 final 局部内部类 的方法只允许访问所在方法的局部变量，不可做修改操作 在使用所在的方法的局部变量时，需要保证局部变量已经初始化 局部内部类访问所在方法的局部变量，要求改局部变量必须使用 final 修饰，在 JDK 8 及以后，由 Java 编译器默认添加 匿名内部类 匿名内部类：不存类名的类，适用于只创建一次的对象 例如，匿名内部类可以应用于一次性线程对象的创建 匿名内部类 的语法结构：new 类名 (){} 匿名内部类 只可以实现一个接口，且必须实现所有方法 匿名内部类 不可以是抽象类，它是具体的实现 匿名内部类 不存在类名，也就没有构造方法，也不存在修饰符 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:50:16 "},"面向对象的思想/异常处理.html":{"url":"面向对象的思想/异常处理.html","title":"异常处理","keywords":"","body":"异常的概念 在 Java 中，不是所有的程序最终都可以正常的运行 简单的说，长度为 3 的数组，访问索引 3，这就是一个错误，数组索引下标越界异常 再例如，Java 操作数据库，编译时不可能确定你的信息是否填写正确 异常分为两类 错误 Error：错误，不可以被处理，只能在开发时注意 异常 Exception：可以被处理，也是主要介绍的部分 对于异常 Exception，又可以分为受检异常、运行时异常 受检异常：程序编译时检查，必须被处理的异常，否则编译不通过 运行时异常（未受检异常）：编译时无法确定的异常，例如空指针异常 运行时异常 RuntimeException 和错误 Error 一样，都是未受检异常，编译时无法确定 上图是 Java 的异常类体系，展示了部分主要、常见的异常类 异常的处理 之前谈到过，受检异常是可以被处理的 异常的处理分为两类，捕获异常、抛出异常 这里主要介绍异常的捕获处理 try { } catch () { } finally { } try {}：放置可能存在异常的程序代码 catch () {}：匹配可能存在的异常信息 finally {}：异常处理完成后，进行的操作 对于 catch () {}，负责预测可能发生异常的代码 catch (Exception e) {} Expection，是所有异常的父类，可以通过它直接匹配到所有可能出现的异常类型 当然，不建议这么做，尽可能的缩小异常的范围，精确匹配 支持多条 catch () {} 匹配，且多个异常类型通过 | 可以存在于一个 catch () {} 在异常匹配中，可以通过如下 API 查看异常 printStackTrace()：打印出异常的堆栈信息 getMessage()：打印出异常的提示信息 也可以直接打印，异常对象的字符串描述，其中包含异常信息、异常提示 值得注意的是，若产生的异常未能被 catch () {} 匹配处理，则后续代码不会被执行 在异常代码之后，还存在其它的程序代码 若异常被捕获处理，后续代码则会正常执行 若异常未被处理或向上抛出，则后续代码不会执行 这里，体现出了 finally {} 的作用，其中的代码，无论异常是否成功捕获，都会执行 异常的抛出 异常可以不再当前类中处理，抛出异常即可 异常的抛出存在两个关键字 throws、throw throws：向上抛出异常，追加在方法的后面 throw：自定义异常，位于方法体内，可以追加异常提示 // throws 示例 public static void main(String[] args) throws Exception{} // throw 示例 throw new Exception(\"异常提示信息\"); 值得注意的是，对于受检异常，throw 必须位于 catch () {} 中，或者使用 throws 自定义异常 Java 中定义了大量的异常类，也可以根据自己的需要，自定义更合适的异常类 public class CustomException extends Exception{ public CustomException() { } public CustomException(String message) { super(message); } } throw new CustomException(\"自定义异常的提示信息\"); Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 09:51:10 "},"面向对象的思想/常用类.html":{"url":"面向对象的思想/常用类.html","title":"常用类","keywords":"","body":"包装类的概念 什么是包装类？它们设计的意义是什么？ Java 是较为纯粹的面向对象设计语言，而其中存在八个原始类型，不归于类的范畴。为了践行 无物不可引用，万类皆是对象，Java 为原始类型提供了对应的引用类型（基本类型又可以称为原始类型），称其为原始类型的包装类 在写法上，除了 int、char，其它六种包装类均为首字母大写，例如 byte 与 Byte。而 int、char 是缩写，其包装类分别是 Integer、Character 相较于基本类型，包装类作为引用类型，可以存在 NULL 值。同时，提供了一些方法，例如 // 求最小求值 int minValue = Integer.MIN_VALUE; // 求最大取值 int maxValue = Integer.MAX_VALUE; // 二进制位数 int size = Integer.SIZE; // 所占字节数 int bytes = Integer.BYTES; 需要注意，Byte、Short、Integer、Long、Float、Double 同属于 Number 数值类，Character、Boolean 不是 明确一点，所有的包装类，都是 final 不可变类，这点与 String 是一致的，任何的修改都是新对象的创建 简单些说，引用类型的赋值，实际是获得堆内存的引用地址，而对于不可变类，任何的修改都会创建新的地址，原有的内存空间不再指向 而对于其它的可变引用类型，如数组（数组不可变的是类型、长度，而非内容），内容的修改不会导致新的数组（内存空间）创建 int[] ints1 = new int[3]; // ints 1 与 ints 2 使用了同一份内存空间 int[] ints2 = ints1; ints1[2] = 3; System.out.println(Arrays.toString(ints2)); /* [0, 0, 3] */ 这些，需要格外注意，什么才是真正的 final 不可变，赋值与声明同步，此后不可修改 如 Integer、String 这些不可变类，是借由 final 完成的修饰。所以，若需要修改其中的内容，必须开辟新的内存空间，这会造成不必要的浪费，也是各种缓存机制存在的必然 // Integer 类已经前缀了 final，意为不可变的类 public final class Integer extends Number implements Comparable {} 拆箱、装箱 拆、装箱，是原始类型与引用类型之间的相互转换 装箱：基本类型转为其包装类 valueOf() 拆箱：包装类转为其基本类型 intValue() 目前，Java 已经支持了自动装箱、自动拆箱，无须再调用特定的方法进行手动拆、装箱 包装类的拆箱、拆箱 示例，仅作了解即可 /* 手动装箱 */ Integer integer1 = Integer.valueOf(12); /* 手动拆箱 */ int intValue1 = integer1.intValue(); /* 自动装箱 */ Integer integer3 = 12; /* 自动拆箱 */ int intValue2 = integer1; 缓存池 包装类中，存在缓存池的设置，避免对象的重复创建，以 Integer 为例 在 Integer 类中，存在一个私有静态内部类 private static class IntegerCache {} 简单的理解，Integer 类的装箱操作，会调用 valueOf()，并开辟一块新的堆内存 无论是手动装箱，还是自动装箱，都会调用 valueOf()，只是隐藏了这部分 若装箱后的 Integer 对象存在于 Integer 的缓存池中，则不会创建新对象，而是直接引用自缓存池 IntegerCache Integer a1 = 120; Integer a2 = 1200; Integer b1 = 120; Integer b2 = 1200; /* == 对于引用类型，比较的是堆内存地址，Java 中也不支持运算符重载 */ System.out.println(a1 == b1); System.out.println(a2 == b2); /* true、false */ 上述的包装类示例，违背了以往的认知，这就是缓存池在发挥作用！对于引用类型，== 是比较二者的堆内存地址，同样数值的 Integer 类型，为何会出现堆内存地址相同、相否的情况 当调用 valueOf() 时，会先判断当前创建的对象是否存在于缓存池中 public static Integer valueOf(int i) { // 判断当前原始类型数值，是否存在于缓存池中 if (i >= IntegerCache.low && i 下述是 Integer 缓存池的具体实现源码 private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k = 127; } private IntegerCache() {} } 通过一系列的示例、源码，可以很清楚的认识到缓存池。根据包装的原始类型大小，决定是否新建对象，还是从缓存池中取出相同的对象 在 Integer 中，缓存池是 -128~127，一个 byte 的取值范围。可以手动的扩充缓存池的大小，但并不推荐这样做 当然，若是直接使用 new Integer()，可以创建一个新的 Integer 对象，但已经废弃。关键字 new，为强制创建，无视缓存池机制 值得注意的是，并非所有的包装类都存在缓存池，浮点型的 Float、Double 与 Boolean 不存在缓存池的概念。Byte、Short、Integer、Long、Character 存在缓存池，默认范围都是 -128~127 重写 equals() 同样的以 Integer 为例，探讨其中的方法重写。在 Integer 类、String 类中，对于 Object 类的 equals() 方法已经被重写 默认的 equals() 方法，对于引用类型，比较的是 变量是否引用自同一对象，判断的依据是堆内存地址。在重写之后，根据实际的数值判断 Integer a = 12; Integer b = 12; Integer c = new Integer(12); /* == 不可重写，依旧是根据对象的引用地址判断 */ System.out.println(a == b); System.out.println(a == c); /* equals() 已被重写，根据对象的值进行判断 */ System.out.println(a.equals(b)); System.out.println(a.equals(c)); /* true、false、true、true */ 上述的示例可以看出 a、b 由于 Integer 的缓存池机制，引用的是同一个对象，堆内存地址与实际数值皆一致 c 通过关键字 new，没有引用缓存池，而是全新的堆内存地址，但实际数值依旧保持一致 在 == 的判断中，不存在问题，a 与 b 相等，与 c 不相等 可是，equals() 的默认实现，是根据对象的引用地址进行的。而经过 Integer 的重写，根据实际的数值判断，以至于堆内存不同的变量在 equals() 的判断中为 true 所以，请看 Integer 类中的重写实现，与 Object 类中的默认实现，二者的区别 /* Object 类的默认 equals() 方法，其中 this 指代当前对象 */ public boolean equals(Object obj) { return (this == obj); } /* Integer 重写后的 equals() 方法 */ public boolean equals(Object obj) { if (obj instanceof Integer) { /* Integer 类的 equals() 根据值判断二者的相等 */ return value == ((Integer)obj).intValue(); } return false; } 重写 hashCode() Object 类中，也存在一个方法，hashCode()，负责返回对象的哈希值 共同的认知是，重写 equals() 的同时，必须重写 hashCode() 哈希值是根据对象的属性，在通过哈希算法生成的，在 Integer 重写之后，规则发生改变，Integer 的哈希值等于它的数值本身 @Override public int hashCode() { return Integer.hashCode(value); } 值得注意的是 相同的对象，哈希值一定相同 而哈希值相同的对象，也可能不是同一个对象 // Arrays.hashCode() 也重写 hashCode()，暂时不用 int[] ints = new int[2]; System.out.println(ints.hashCode()); System.out.println(new int[2].hashCode()); /* 哈希值：2083562754、1239731077 */ hashCode() 的默认实现，是将对象的引用地址转换为整数值。引用地址右虚拟机生成，可覆盖 可以参考 HashMap 中的键值存储形式，它允许存在重复的 hash 值，以单向链表的形式存储 对于 equals() 与 hashCode()，优先是通过对象的哈希值判断相等性。若哈希值不同，则并非同一个对象；若哈希值相同，则根据 equals() 二次判断。这样，可以达到性能与安全的平衡 若 equals() 重写，而 hashCode() 不重写，根据对象的值进行判断，则会出现，equals() 判断为 true，而 hashCode() 不相同，以至于操作失误 简单的理解为：equals() 判断为 true，则 hashCode() 必须为 true；而 hashCode() 为 true时，equals() 存在为 false 的可能 String 存储位置 String 类经常使用，所以 Java 也对它做了 “缓存” 处理 String 类是不可以变的字符数组，任何的修改都会生成新的 String 对象 在 JVM 虚拟机中，存在一个特殊的内存空间，常量池 对于普通方式创建的字符串，则放入常量池中，可以参考 Integer 类的缓存池 String a = \"1\"; String b = \"1\"; // == 用于比较对象的引用地址 System.out.println(a == b); /* true */ 当直接赋值为字符串字面量时，相同内容的新对象，也会被认为是同一个对象 String a = \"1\"; String c = new String(\"1\"); System.out.println(a == c); /* false */ 关键字 new，强制在堆内存中，创建一个新的 String 类对象，不存入常量池 值得注意的是，字符串的实际存储位置，或者说常量池位置，随着 JDK 版本迭代而变更 例如，在 JDK8.0 中，常量池已经由方法区移动至堆内存中 StringBuffer、StringBuilder String 类是不可变的，每次修改都会创建新的对象，这样的效率并不是很高 Java 中提供了两个可变长的字符串类，StringBuffer、StringBuilder StringBuffer：JDK1.0 提供，线程安全、运行效率慢 StringBuilder：JDK5.0 提供，线程不安全、运行效率快 这两个方法中，常用的是 StringBuild，并且二者的实现是差不多的 核心在于线程的安全与否，而保证线程的同时，不可避免的降低执行效率 简单的说，StringBuffer、StringBuild 的本质也是字符数组 不同的是，这二者的字符数组，其每一个元素为一个字符串，而不是纯粹的单个字符 二者对于 String 类的改造，在于字符数组的可扩容 在对字符串做修改时，String 类是直接创建新的对象，原内存直接废弃 而 StringBuffer、StringBuilder 则是将该内存 扩容 以下是 StringBuilder 的 API appeand(String str)：添加 String 对象至字符数组中 appeand(StringBuilder sb)：添加 StringBuilder 对象值字符数组中 delete(int start, int end)：删除字符数组中的部分元素 可以看出，StringBuilder 使用方法 appeand() 替代了 String 类拼接字符的 + 现在，简单介绍一些，StringBuilder 对于字符数组扩容的操作 初始大小：StringBuilder 继承抽象父类，默认字符数组长度为 16 public StringBuilder() { super(16); } 添加 String 对象：添加 String 对象之前，先判断字符数组是否需要扩容 // StringBuilder 的对象添加，已经交由抽象父类完成 public AbstractStringBuilder append(String str) { if (str == null) { return appendNull(); } int len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; return this; } 字符数组扩容：是否需要扩容，是根据添加当前 String 对象后的字符数组长度确定的 // 判断添加 String 对象是否超出长度，若超出，则扩容为之前的两倍 private void ensureCapacityInternal(int minimumCapacity) { int oldCapacity = value.length >> coder; if (minimumCapacity - oldCapacity > 0) { value = Arrays.copyOf(value, newCapacity(minimumCapacity) StringBuild 的扩容，使得无需再开辟新的内存空间 简单的理解，StringBuilder 相当于 String 类的容器 接下来，简单介绍 StringBuffer 的线程安全问题，当然，这不常用 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 上述为 StringBuffer 的字符串对象添加方法，这直接解释了线程安全的缘由 StringBuffer 在修饰符、返回值类型之间，加入了 关键字 synchronized synchronized：线程安全，该方法同一时间点，只允许一条线程进行操作 String 类的不可变，使得程序安全、简单且易于理解，但频繁的创建新对象，则使得效率较低 StringBuffer、StringBuilder 在则通过 扩容，避免了频繁的内存操纵 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:00:30 "},"存储数据的容器/":{"url":"存储数据的容器/","title":"存储数据的容器","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-08 13:30:13 "},"存储数据的容器/泛型的概念.html":{"url":"存储数据的容器/泛型的概念.html","title":"泛型的概念","keywords":"","body":"泛型的概念 泛型，意为广泛的类型。它可以为容器中存储的类型限定一个范围。这个范围可以是具体的类或其子类、父类。对于泛型的定义，是作为参数传入到容器中，例如 public class 类名 {} 对于泛型，可以被应用与类、接口、方法、属性中，泛型只允许为引用类型 对于广泛的类型：可以使用泛型作为占位符，当实际使用时，再指定实际的类型 对于类型参数化：作为一个参数传入，并在程序编译后，替代为具体的类型，即 泛型擦除 对于类型安全：当指定具体的类型时，Java 编译器会判断类型转换的合法性，规避 ClassCastExcepttion 泛型是开发中的一大利器，动态的设置参数的类型，使得程序更为灵活、易用，若不指定，则默认为 Object 对于泛型的认识，需要注意泛型使用的符号的含义，理解泛型擦除的概念 泛型擦除：Java 编译器将泛型符号替换为 Object，再转换为具体的类型 在 Java 中，泛型根据功能定位的不同，可以分为以下几类。当然，可以自定义，大多无实际意义 泛型符号 符号说明 E 容器元素 T 普通 Java 类 K 键 V 值 N 数值类型 泛型的符号定义、符号数量无限制，但一般使用具有特定含义的符号 ? 存在特殊含义 -> 无界通配符，其余的泛型符号可以变更，不存在特殊作用 对于泛型类、泛型接口、泛型方法：泛型方法可以使用泛型类、泛型接口定义的泛型符号 泛型类 泛型类的语法结构：public class 类名 {} 当一个类定义为泛型类时，它的泛型符号可以被其属性、方法使用 注意！属性不可以独自声明为泛型，只可以接收自泛型类、泛型接口 泛型类的示例 public class Person { private T name; private N age; public Person(T name, N age) { this.name = name; this.age = age; } public T getName() { return name; } public void setName(T name) { this.name = name; } public N getAge() { return age; } public void setAge(N age) { this.age = age; } } 上述是一个典型的泛型类，它定义了两个泛型符号，T、N 泛型类、接口、方法在被使用时，必须声明其实际的类型，不再是泛型符号 Person person = new Person<>(\"张三\", 29); 泛型接口 泛型接口的语法结构：public interface 接口名 {} 泛型接口与泛型类相似，以下是泛型接口及实现的代码示例 public interface Animal { T food(); } public class FishImpl implements Animal { @Override public String food() { return null; } } 同样的，在继承、实现泛型类、泛型接口时，也必须指定具体的类型替代泛型占位符 当然，也可以继续使用泛型符号，如同抽象子类也无须重写抽象父类的抽象方法 泛型方法 泛型方法的语法结构：public 泛型符号 方法名 (泛型符号 参数名) {} 泛型方法的泛型符号，位于 修饰符 和 返回值类型 之间，返回值类型也可以定义为泛型 当使用泛型代替返回值类型时，无需尖括号 <>，仅限于非静态泛型方法 返回值类型的泛型符号不可独自声明，必须与泛型类、接口、方法一致 泛型方法分为静态、非静态，以下是方法声明泛型符号时的注意点 泛型方法的实际类型无需声明，根据传入的参数值由编译器确定 对于静态泛型方法，它的泛型符号必须由当前方法定义 对于非静态泛型方法，可以向上使用泛型类、泛型接口的泛型符号 对于实例泛型方法，它的泛型符号可以由泛型类、泛型接口指定 对于静态泛型方法，它的泛型符号仅可以自定义、自使用，不可接收泛型类、泛型接口的泛型符号 静态属性、静态方法在程序编译时确定，不可使用泛型类定义的泛型符号 静态、非静态泛型方法代码示例 public class Ma { public static T get(T food) { return food; } public N set(N number) { return number; } } System.out.println(Ma.get(\"皮皮虾\")); Ma integerMa = new Ma<>(); integerMa.set(123); 值得注意的是 由于泛型类型的不确定性，多个泛型之间不可以进行相加等修改操作 当然，这并不影响泛型类型的元素遍历等非修改操作 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:08:28 "},"存储数据的容器/泛型的通配.html":{"url":"存储数据的容器/泛型的通配.html","title":"泛型的通配","keywords":"","body":"无界通配 泛型符号中，存在一个可以指代任意类型的 ?，这就是无界通配符 无界通配符：对于类型无限定，可传入任意类型 无界通配符存在的意义是为了限定泛型可以表示的类型范围，由无界通配符转为有界通配符 泛型在类型擦除后，为 Object 类型，或者是其它指定的具体的类型 但是，也造成了一点，这样的泛型并不具有继承性，真正限定为了一个类型 泛型类型一旦确定，不可修改，也不参与到 Java 的继承体系中 当某个类的泛型被声明为 Number ，它就不能再接收 Number 类的子类 简单的理解，确定之后的泛型类型，不再具备继承性 public class A { private T age; } public class B { public void get(A age) { } } public class M { public static void main(String[] args) { B b = new B(); /* 正确 */ A numberA = new A<>(); b.get(numberA); /* 错误 */ A integerA = new A<>(); b.get(integerA); } } 在上述的示例中，形式参数声明为 Number 类型，却无法兼容它的子类 Integer 当然，可以将 B 类已经确定的 A 类类型 Number，再次声明为泛型，但这不是继承体系下的兼容 实际使用时，不可使用泛型，仅支持泛型类继承泛型类的形式 这就是无界通配符、有界通配符存在的必要 限定泛型可以被声明的范围，存在边界的限制 使得声明后的具体类型，可以加入到继承体系中 它们可以限定泛型的范围，做到父类、子类的继承性 有界通配符，相当于限定了该泛型向上、向下兼容的范围 无界通配符转为有界通配符后，分为两类 上限限定通配符 下限限定通配符 上限限定 上限限定通配符的关键字为 extends 语法结构为 上限限定表示的是，可以接收此实际类型及它的子类 简单的理解为，实际类型作为泛型的最高父类存在 代码示例 public class A { private T age; } public class B { public void get(A age) { } } public class M { public static void main(String[] args) { B b = new B(); /* 正确 */ A numberA = new A<>(); b.get(numberA); /* 正确 */ A integerA = new A<>(); b.get(integerA); } } 仅需对 B 类型方法中，A 类泛型做有界上限限定即可 此时，A 类的上限限定为 Number ，可以接收 Integer、Number 参数 通过指定泛型表示的范围，实现泛型类型的继承性，可以向下兼容子类 下限限定 下限限定通配符的关键字为 super 语法结构为 下限限定表示的是，可以接收此实际类型及它的父类 简单的理解为，当前指定的实际类型作为泛型的最低子类存在 代码示例 public class A { private T age; } public class B { public void get(A age) { } } public class M { public static void main(String[] args) { B b = new B(); /* 正确 */ A numberA = new A<>(); b.get(numberA); /* 错误 */ A integerA = new A<>(); b.get(integerA); } } 仅需对 B 类型方法中，A 类泛型做有界下限限定即可 此时，A 类的下限限定为 Number ，不可以接收 Integer 参数 值得注意的是： 泛型类可以做上限限定 public class 类名 {} 泛型类不可以做下限限定 public class 类名 {} 对于有界通配符，可以使用泛型符号替代 ?，但不可用作下限限定，即超类型通配符 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:09:02 "},"存储数据的容器/容器的概念.html":{"url":"存储数据的容器/容器的概念.html","title":"容器的概念","keywords":"","body":"容器的概念 容器：容纳数据元素的器皿，但只存储引用类型对象 容器的概念与数组相似，都是为了存储数据而存在的，但容器的应用范围更为广泛 在 Java 的容器体系中，存在一个 Collection 接口，作为容器的顶级接口存在 由它派生出两个子接口 List、Set，同时，还存一个独立于该接口的容器接口 Map，也是容器的顶级接口 也就是说，Java 的容器中存在两个顶部接口，Collection 接口、Map 接口 详细的继承、实现关系，可以借助 IDEA 的图表功能查看，这里图片较为简略 Collection 接口定义的两个子接口 List 、Set，都是单例集合，每次只能存储一个数据元素 Map 接口则是双例集合，按照键值的 K,V 的形式，同时存储两个数据元素 对于 Map，第一个元素 键 相当于第二个元素 值 的地址 简单理解 List 列表容器中的索引下标与值，但 Map 中的键可以自由定义 在 Collection 接口中，定义了如下的公共方法 boolean add(Object element) ：增加元素到容器内 boolean remove(Object element) ：从容器中移除元素 boolean contains(Object element) ：容器中是否包含该元素 int size() ：容器中元素的个数 boolean isEmpty() ：容器是否为空 void clear() ：清空容器中的所有元素 Iterator iterator() ：获取迭代器，遍历所有元素 boolean containsAll(Collection c) ：本容器是否包含目标容器的所有元素 boolean addAll(Collection c) ：将目标容器的元素加入到本容器中 boolean removeAll(Collection c) ：移除本容器和目标容器都存在的元素 boolean retainAll(Collection c) ：移除本容器和目标容器都不存在的元素 Object[] toArray() ：转换为 Object 数组 基于 Collection() 接口定义的方法，可以发现，偏向于无序 Set 集合 List 接口 List 接口存在两大特征 数据元素 有序存储，存在索引下标 数据元素 重复存储，存在相同元素 List 接口在继承 Collection 接口的基础上，扩展了如下方法 void add(int index, Object ekement) ：指定位置插入元素，此后元素后移 Object set(int index, Object ekement) ：修改指定位置的元素 Object get(int index) ：返回指定位置的元素 Object remove(int index) ：删除指定位置的元素，此后元素前移 int indexOf(Object o) ：返回第一个匹配元素的索引，若不存在则为 -1 int lastIndexOf(Object o) ：返回最后一个匹配元素的索引，不存在返回 -1 List 中扩展的方法，是需要索引下标的介入，数据元素是有序存储、取出 Map 接口 之前提到过，Map 并没有继承 Collection 接口 Map 接口是独立存在的容器接口，而 Collection 接口下的实现类，为单例容器 对于Map的双例容器，也可以称为 键值容器，以 K、V 的形式进行存储 简单的理解，Map 每次存储的数据元素是成对出现的，而单例集合仅存在一个元素 对于 Map 容器中的键 K，可以 简单的看作是列表容器的索引，只是该“索引”可以自定义 Map 中的键、值，键不可以重复；值可以重复；且 一个键对应一个值 以下是 Map 中定义的常用方法 V put(K key, V value)：添加元素，以 K、V 键值对的形式 V get(Object key)：根据 key，获取 Value V remove(Object key)：删除指定 Key boolean containskey(Object key)：是否存在指定 Key Set keySet()：获取 Map 中的所有 key，存储入 Set 中 void clear()：删除 Map 中的所有键值对 值得注意的是，Map 中的添加，已经有 add() 变更为了 put() Map 接口、Collection 接口，需要注意使用上的差异 在 Map 集合中，常用的有 HashMap、TreeMap Set 接口 Set 接口存在两大特征 数据元素 无序存储，不存在索引下标 数据元素 不可重复，不存在相同元素 Set 接口并未扩展 Collection 接口的方法，这也是容器，可以被称为集合容器的缘由 未扩展 Collection 接口方法的 Set 接口，其内部方法无变动 boolean add(Object element) ：增加元素到容器内 boolean remove(Object element) ：从容器中移除元素 boolean contains(Object element) ：容器中是否包含该元素 int size() ：容器中元素的个数 boolean isEmpty() ：容器是否为空 void clear() ：清空容器中的所有元素 Iterator iterator() ：获取迭代器，遍历所有元素 boolean containsAll(Collection c) ：本容器是否包含目标容器的所有元素 boolean addAll(Collection c) ：将目标容器的元素加入到本容器中 boolean removeAll(Collection c) ：移除本容器和目标容器都存在的元素 boolean retainAll(Collection c) ：移除本容器和目标容器都不存在的元素 Object[] toArray() ：转换为 Object 数组 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 19:02:55 "},"存储数据的容器/ArrayList类.html":{"url":"存储数据的容器/ArrayList类.html","title":"ArrayList","keywords":"","body":"基本使用 ArrayList 是常用的容器，基于 数组实现，非线程安全 ArrayList中定义的常用方法 void add(int index, E element：插入元素在指定位置 boolean add(E e)：插入元素，在列表的末尾 boolean addAll(int index, Collection c)：插入容器，在指定位置 boolean addAll(Collection c)：插入容器，在列表的末尾 void clear()：清空当前容器 boolean contains(Object o)：是否存在指定元素 void forEach (Consumer action)：数据元素的遍历 E get(int index)：取出元素，在指定位置 int indexOf(Object o)：返回某个元素的首次出现位置的索引 boolean isEmpty()：当前容器是否为空 iterator iterator()：返回列表实例的迭代器对象 int lastIndexOf(Object o)：返回某个元素的最后一次出现位置的索引 ListIterator listIterator()：返回列表迭代器 ListIterator listIterator(int index)：返回当前列表部分元素的迭代器 E remove(int index)：删除指定索引的元素 boolean remove(Object o)：删除指定元素 // 右侧实例对象的泛型类型可以不指定 List list = new ArrayList<>(); // 添加元素 list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); // 获取元素 System.out.println(list.get(0)); // 删除元素 System.out.println(list.remove(0)); // 替换元素 list.set(0, \"D\"); // 清空容器 list.clear(); // 判断容器是否为空 System.out.println(list.isEmpty()); // 判断容器中是否包含指定元素 list.add(\"E\"); System.out.println(list.contains(\"C\")); // 查找元素的位置 System.out.println(list.indexOf(\"E\")); // 单例集合转为数组 Object[] objects = list.toArray(); 迭代器实现 在 Java 的容器中，迭代器是一个很重要的概念 简单的理解，迭代是用于遍历容器中的数据元素 public interface Iterable { Iterator iterator(); default void forEach(Consumer action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } default Spliterator spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } 上述是迭代器 Iterable 的源码，从这可以看出很多东西，其中最醒目的 default void forEach(Consumer action) {} 迭代器中定义的这个方法，竟是 forEach，流程控制的一种 由此可见，forEach 是对于 for i 的简化，底层是基于迭代器实现的 ArrayList 容器也实现了迭代器接口，但 不是直接实现的，而是通过层层继承 ArrayList 继承 AbstractList public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable {} AbstractList 继承 AbstractCollection public abstract class AbstractList extends AbstractCollection implements List {} AbstractCollection 实现 Collection public abstract class AbstractCollection implements Collection {} Collection 继承 Iterable public interface Collection extends Iterable {} 接下来，是 ArrayList 内部对于迭代器的使用，Iterator() 方法 public Iterator iterator() { return new Itr(); } // 定义在 ArrayList 内部的成员内部类 private class Itr implements Iterator { // 返回下一个元素的索引位置 int cursor; // 返回下一个元素的索引位置，若不存在，则为 -1 int lastRet = -1; // 实时记录容器元素的操作次数，避免并发修改 int expectedModCount = modCount; // 是否存在下一个数据元素 public boolean hasNext() {} // 获取下一个数据元素 public E next() {} // 移除最后一个获取的数据元素 public void remove() {} } 接下来，通过 ArrayList 中的实现，了解迭代器的工作原理 // 第一步：判断是否存在下一个元素 public boolean hasNext() { // cursor：下一个数据元素的索引位置 // size：记录 ArrayList 实际存在的数据元素个数 // 原理：若 cursor、size 不相等，则存在下一个数据元素 return cursor != size; } // 第二步：获取下一个元素 public E next() { // 判断当前的容器是否正在被其它线程操作、修改，保证 modCount 的一致性 checkForComodification(); int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); // 更新下一个元素的索引位置 cursor = i + 1; // lastRet 返回当前元素索引，course 初始值 为 0，i 为 0 return (E) elementData[lastRet = i]; } final void checkForComodification() { // modCount：记录 ArrayList 中修改操作的次数 // expectedModCount：实时保存 modCount if (modCount != expectedModCount) throw new ConcurrentModificationException(); } // 第三步：删除最后一个获取的元素 public void remove() { // lastRet：实时记录最后一个元素的索引位置，-1 不存在元素 if (lastRet 多么酣畅淋漓的解读，这就是 ArrayList 中对于迭代器的实现 这里，需要注意迭代器内部的 remove() 删除当前索引位置的元素 ArrayList.this.remove(lastRet); 之后的元素的索引需集体前移一位 cursor = lastRet; 对于 remove()，需要先调用 next，否则会造成 IllegalStateException 现在，源码又一次解读了疑惑，2021-04-15 16:14 基于 ArrayList 的迭代器实现，可以发现，线程不安全的特点 若是多个线程同时操作、修改一个 ArrayList 容器，或使用迭代器，极易产生异常 所以，ArrayList 迭代器实现，需要 modCount 实时记录容器的操作次数，避免并发修改 当然，迭代器本身是非常有用的，对于不存在索引下标的容器，比如遍历 Set 集合 值得一提的是，迭代器在元素的操作上，效率是比 get() 等方法更高一些的 初始化 ArrayList 无参构造：初始化时，数组默认为空 public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } elementData ：元素数据，定义为 Object 类型的数组，初始为 Null DEFAULTCAPACITY_EMPTY_ELEMENTDATA ：静态不可变的 Object 空数组 ArrayList 有参构造：初始化时，可以指定数组的长度 public ArrayList(int initialCapacity) { if (initialCapacity> 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity:\"+ initialCapacity); } } initialCapacity 作为形式参数，代表在实例化时指定的数组长度 EMPTY_ELEMENTDATA ：静态不可变的 Object 空数组 若 initialCapacity 大于 0，则新建对应长度的 Object 数组 若 initialCapacity 等于 0，则赋值一个新的 Object 空数组 EMPTY_ELEMENTDATA 若 initialCapacity 小于 0，则抛出异常 IllegalArgumentException 参数接收错误 扩容 ArrayList 元素添加：ArrayList 扩容的开始 // 第一步 添加元素 public boolean add(E e) { // 记录容器内部的修改次数 modCount++; // 实际调用的添加方法 add(e, elementData, size); return true; } // 第二步 判断数组长度 private void add(E e, Object[] elementData, int s) { // elementData：当前数组的长度，此时传入的元素不计算在内 if (s == elementData.length) // 当前数组已满，开始扩容，调用 grow() elementData = grow(); elementData[s] = e; // size：当前数组中实际存储的元素个数 size = s + 1; } private Object[] grow() { return grow(size + 1); } private Object[] grow(int minCapacity) { // 将扩容的新数组拷贝给 elementData 数组 return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } // 第三步 创建新的数组对象 private int newCapacity(int minCapacity) { int oldCapacity = elementData.length; // 新数组扩容为老数组的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity>> 1); // 判断扩容 1.5 倍之后的新数组，是否足够存储添加的元素 if (newCapacity - minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 以上是对 ArrayList 源码的分析，当前版本为 JDK11.0.10 可以看出一些有意思的地方 初始化时，存储数组作为空数组存在，这与主流的 JDK8 是不同的 当第一次添加元素时，默认分配的数组长度为 10 在一次扩容操作中，最多仅作两次新数组的创建，二次扩容至极限 从数组的二次扩容 hugeCapacity(int minCapacity) 中，可以看出，最大扩容为 int 的最大取值 对于 ArrayList 首次添加元素时，也会扩容，注意此前的方法 private int newCapacity(int minCapacity) 若对新的 ArrayList 容器添加多个元素 // 判断新数组是否小于老数组 if (newCapacity - minCapacity private static final int DEFAULT_CAPACITY = 10;：默认扩容大小 对于源码的阅读，一定要根据 JDK 版本的不同而加以区分 以 ArrayList 为例，在之前版本，初始化时，即默认数组长度为 10 而在 JDK11 中，初始化为空数组，实际添加元素后，才会可能默认分配数组长度为 10 源码的阅读是非常有帮助的，就好比可能存在的一个疑问 ArrayList 内部是 Object() 数组，那为何可以限制传入的数据元素类型 public class ArrayList ....{} public boolean add(E e) {} 并且，以 Object 类型的数组进行存储，取出时不是 Object 类型 public E get(int index) { Objects.checkIndex(index, size); // 返回对应位置的数据元素，调用 elementData(int index) return elementData(index); } E elementData(int index) { // 返回存储数组中的对应元素，并进行类型转换 return (E) elementData[index]; } 只需要打开源码，大多数的问题都可以迎刃而解 不要畏惧未知，骚年 击溃你的，不是困难本身，而畏惧困难时的迷茫 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:12:09 "},"存储数据的容器/Vector类.html":{"url":"存储数据的容器/Vector类.html","title":"Vector","keywords":"","body":"基本使用 Vector 也是基于数组实现的，常用方法与 Arraylist 类似 值得注意的是，Vector 是 线程安全的容器 相反，ArrayList 是线程不安全的容器 这也就造成了 ArrayList、Vector 容器的差异：Vector 在保证了线程安全的同时，在使用效率上就低于 Arraylist 在实现线程安全的同时，不可避免的造成更多的资源开销 这里，可以尝试大批量向 ArrayList、Vector 中插入元素，计算程序的执行时间 二者的使用需要根据实际的场景确定，ArrayList 依旧是最常用的容器类 另外，Vector 下还有一个子类，Stack，可以扩展部分功能 Vector 子类 Stack Stack 作为 Vector 的子类，它的底层是基于 栈 实现的 Stack 栈容器的特有方法 boolean empty() ：判断此栈是否为空 E peek() ：查看栈顶的元素对象 E pop() ：删除栈顶的元素对象，并返回该对象 E push(E item) ：添加一个数据元素至栈顶 int search(Object o) ：返回某个对象在栈中的位置 Stack 栈容器的扩展方法 使用示例 Stack stack = new Stack<>(); // 元素添加 stack.push(\"1\"); stack.push(\"2\"); stack.push(\"3\"); // 查看栈顶的元素对象 System.out.println(stack.peek()); // 判断此栈是否为空 System.out.println(stack.empty()); // 删除栈顶的元素 System.out.println(stack.pop()); // 遍历栈中的元素，索引自栈底向栈顶 for (String s : stack) { System.out.println(s); } // 查看某个对象在栈中的位置，当对象不存在时，返回 -1 System.out.println(stack.search(\"3\")); 线程安全 之前说到过，Vector、ArrayList 的常用方法、源码组成大致相同 二者最大的区别在于，Vector 是线程安全的 现在，开始分析 Vector 的源码，找出其实现线程安全的关键 Vector 添加元素：注意 synchronized // synchronized 修饰的方法，在同一时间点，只允许被一个线程访问、使用 public synchronized boolean add(E e) { modCount++; add(e, elementData, elementCount); return true; } 上述是 Vector 的元素添加方法，可以很清晰的看到不同，synchronized 关键字做修饰 打开 Vector 其它的涉及数组操作的方法，都可以看到 synchronized 的存在 public synchronized E remove(int index) {} public synchronized boolean addAll(int index, Collection c) {} 初始化 Vector 的初始化：默认数组的长度是 10 // 第一步：无参构造，传入 10 public Vector() { this(10); } // 第二步：有参构造 public Vector(int initialCapacity) { this(initialCapacity, 0); } // 第三步：有参构造 public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity 与 ArrayList 不同，Vector 在初始化时，便将数组的长度扩容为 10 简单的说，ArrayList 默认数组为空，而 Vector 默认数组为 10 扩容 Vector 元素添加：添加元素时，可能会进行二倍的数组扩容 public synchronized boolean add(E e) { modCount++; add(e, elementData, elementCount); return true; } private void add(E e, Object[] elementData, int s) { // 判断当前元素个数是否与数组长度相等 if (s == elementData.length) // 开始扩容，依旧是 grow() 方法 elementData = grow(); elementData[s] = e; // elementCount：当前数组的实际元素个数，与 ArrayList 的 size 类似 elementCount = s + 1; } private Object[] grow() { return grow(elementCount + 1); } // 拷贝新数组，完成旧数组的扩容 private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } // 数组扩容，创建新数组 private int newCapacity(int minCapacity) { int oldCapacity = elementData.length; // capacityIncrement：记录当前数组的容量增长，可见于构造方法的扩容 // Vector 默认扩容至原有长度的两倍，与 ArrayList 的 1.5 被不同 int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 与 ArrayList 相比，Vector 的扩容还是存在区别的：每次扩容，增加至原来的二倍 当然，在大体的流程上，还是极为相似的 Vector 的源码分析并不复杂，核心就是线程安全的部分，在扩容上无明显变化 再次强调，源码的分析必须结合 JDK 的版本 官方的源码并非一成不变，它是随着版本的更新而不断优化的、 若有可能，十年后的人看到这篇文章：这写的什么垃圾玩意，还 JDK11！？？？ Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:12:36 "},"存储数据的容器/LinkedList类.html":{"url":"存储数据的容器/LinkedList类.html","title":"LinkedList","keywords":"","body":"基本使用 LinkedList 的底层基于 双向链表 实现，这与 Arraylist、Vector 的 数组 实现是不同的 基于 双向链表 实现的 LinkedList 具有如下的特点 数据元素的增加、删除操作较快，它的 修改、删除效率高 相对于数组实现的 ArrayList ，它的 查询、添加效率低 相对于线程安全的 Vector ，它的 线程不安全 ArrayList arrayList = new ArrayList<>(); long startTime1 = System.currentTimeMillis(); for (int i = 0; i LinkedList linkedList = new LinkedList<>(); long startTime2 = System.currentTimeMillis(); for (int i = 0; i 上述的代码，是测试 ArrayList、LinkedList 在插入元素时的时间消耗 同样的，也可以用于测试修改元素的时间消耗 这可以很明确的认识到：数组、链表这两个数据结构的差异 同样继承自 List 接口的 LinkedList 容器，扩展方法 如下 void addFirst(E e) ：将指定元素插入到开头位置 void addLast(E e) ：将指定元素插入到结尾位置 getFirst() ：返回列表的第一个元素 getLast() ：返回列表的最后一个元素 removeFirst() ：移除列表的第一个元素，并返回该元素 removeLast() ：移除列表的最后一个元素，并返回该元素 E pop() ：弹出列表的第一个元素 void push(E e) ：添加元素至列表的开头位置 boolean isEmpty() ：判断列表是否为空 可以看出，链表实现的 LinkedList，在继承 List 接口的同时，拓展了独有方法 LinkedList 的使用案例 LinkedList linkedList = new LinkedList<>(); // 添加元素至列表的开头、结尾 linkedList.addFirst(\"A\"); linkedList.addFirst(\"B\"); linkedList.addFirst(\"C\"); linkedList.addLast(\"D\"); // 获取此列表的第一个元素、最后一个元素 System.out.println(linkedList.getFirst()); System.out.println(linkedList.getLast()); // 移除该列表的第一个元素、最后一个元素，并返回 System.out.println(linkedList.removeFirst()); System.out.println(linkedList.removeLast()); for (String s : linkedList) { System.out.println(s); } // 弹出该列表的第一个元素 removeFirst() System.out.println(linkedList.pop()); // 添加元素至列表的开头位置 addFirst() linkedList.push(\"E\"); // 判断列表是否为空 System.out.println(linkedList.isEmpty()); 值得注意的是，inkedList 除了实现 List 接口，还实现了 Deque 接口 而其中的 Deque 接口，则实现了 Queue 接口 实现 Deque LinkedList直接实现了Deque接口，这是一个双端队列 对于双端队列，它同时具有栈、队列的特征，需要区分开 双端队列，可以在头部、尾部操作数据元素 Deque扩展了如下的方法 void push()：头部添加元素，栈溢出则抛出异常 E push(E e)：查询头部元素，栈为空则返回NULL E pop()：查看并删除头部元素，栈为空则抛出异常 Deque deque = new LinkedList<>(); deque.push(1); deque.push(2); System.out.println(deque.size()); 实现 Queue LinkedList 间接实现了 Queue 接口，这是一个队列 值得注意的是，Queue 接口也继承了 Collection 类，并扩展了一些方法 Queue接口扩展的方法 boolean add(E e)：尾部添加元素 boolean offer(E e)：尾部添加元素 E element()：查询头部元素，但不删除 E peek()：查询头部元素，但不删除 E pull()：查询头部元素，并删除 E remove()：查询头部元素，并删除 Queue integers = new LinkedList<>(); integers.add(1); integers.add(2); System.out.println(integers.size()); 节点对象 对于 LinkedList 源码的分析，是与 ArrayList、Vector 存在较大差异的 LinkedList 基于双向链表实现，而每个存储单元，都存在两个首、尾节点 LinkedList的节点类：私有、静态、内部类 private static class Node { // item：数据元素 E item; // next：下一个节点、尾节点 Node next; // prev：上一个节点、首节点 Node prev; // 建立一个链表存储单元，存在数据元素、两个指向节点 Node(Node prev, E element, Node next) { this.item = element; this.next = next; this.prev = prev; } } 节点添加 LinkedList 的元素添加：正常添加，了解节点类的使用 // 添加元素，在尾部插入节点 public boolean add(E e) { linkLast(e); return true; } // 插入尾节点 void linkLast(E e) { // last：指向后一个节点的指针，开始默认为NULL final Node l = last; // 新建节点对象，填入数据元素 final Node newNode = new Node<>(l, e, null); // 将新建的节点对象，赋值给last指针 last = newNode; // 判断是否存在下一个节点 if (l == null) // 若不存在下一节点，将当前节点设为尾节点 first = newNode; else // 若存在下一节点，将当前节点设为上一节点 l.next = newNode; // size：记录双向链表的节点个数，等同于记录数据元素的个数 size++; modCount++; } 双向链表的节点，理解确实是有些麻烦 现在，向 LinkedList 中插入三个数据元素，成员 A、B、C 添加元素（成员 A）：首、尾节点为 NULL void linkLast(E e) { // last：记录最后一个节点对象，此时为 NULL final Node l = last; // 新建节点对象，首、尾节点为 NULL final Node newNode = new Node<>(l, e, null); // 当前节点对象，赋值给 last 指针 last = newNode; if (l == null) // first：记录了第一个节点对象 // 此时，将成员 A 记录为了第一个节点对象 first = newNode; else l.next = newNode; size++; modCount++; } 添加元素（成员 B）：存在上一节点，成员 A void linkLast(E e) { // last 指针记录了上一节点对象，成员 A final Node l = last; // 新建节点对象，存在上一节点，下一节点为 NULL final Node newNode = new Node<>(l, e, null); // 当前节点对象为成员 B，赋值给 last 指针 last = newNode; if (l == null) first = newNode; else // 将上一节点对象的尾节点设置为当前节点对象 // 成员 A 的下一节点由 NULL 更改为成员 B l.next = newNode; size++; modCount++; } 添加元素（成员 C）：存在上一节点，成员 B void linkLast(E e) { // last 指针记录了上一节点对象，成员 B final Node l = last; // 新建节点对象，存在上一节点，下一节点为 NULL final Node newNode = new Node<>(l, e, null); // 当前节点对象为成员 C，赋值给 last 指针 last = newNode; if (l == null) first = newNode; else // 将上一节点对象的尾节点设置为当前节点对象 // 成员 B 的下一节点由 NULL 更改为成员 C l.next = newNode; size++; modCount++; } 上述是对于 LinkedList 元素添加的源码分析，核心在于节点对象的首尾、前后节点指针 LinkedList 添加头部节点：void addFirst(E e); public void addFirst(E e) { linkFirst(e); } private void linkFirst(E e) { // first：记录了第一个节点对象 // 注意，任意方式添加的第一个节点对象，同时赋值给 last、first final Node f = first; // 建立节点对象，前后节点为 NULL，存储数据元素 final Node newNode = new Node<>(null, e, f); // 当前节点对象，赋值给first，作为第一个节点对象 first = newNode; if (f == null) // 若LinkedList只存在当前一个节点对象，则作为首、尾节点对象存在 last = newNode; else // 若存在其它的节点对象，则作为当前对象的下一节点对象 f.prev = newNode; size++; modCount++; } 从 LinkedList 添加头部节点，可以很清晰的认识到 任何方式添加的第一个节点对象，会同时作为首尾节点存在，并赋值给 first、last first 指针，指向第一个节点对象，首节点的前驱元素为 NULL last 指针，指向最后一个节点对象，尾节点的后继元素为 NULL 除首、尾节点对象外，其余皆存在前、后节点对象 LinkedList 添加指定节点：void add(int index, E element) {}; public void add(int index, E element) { // 判断输入的位置，是否存在问题 checkPositionIndex(index); // 若 index==size，则是作为最后一个节点存在，正常调用 linkLast() // 考虑到了，插入的节点是第一个节点的可能，nice！！ if (index == size) linkLast(element); else // 否则调用 linkBefore(element, node(index)) linkBefore(element, node(index)); } // 判断是否存在问题，抛出的异常为 数组索引越界异常 private void checkPositionIndex(int index) { if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } // 添加指定节点时，index 必须大于、等于 0，小于当前的总节点数 private boolean isPositionIndex(int index) { // size：记录当前的节点数，LinkedList 中已存在的节点对象的总数 return index >= 0 && index succ) { // 获取插入节点的前一节点对象 final Node pred = succ.prev; // 建立新的节点对象 final Node newNode = new Node<>(pred, e, succ); succ.prev = newNode; // 若插入的节点不存在上一节点对象，即该节点为首节点 if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } Node node(int index) { // 判断节点插入的大致位置 if (index > 1)) { // 建立新的节点对象，并赋值为首节点的节点对象 // 首节点指针已经在之前，去除了为 NULL 的可能 Node x = first; for (int i = 0; i x = last; for (int i = size - 1; i > index; i--) // 获取插入节点的上一节点对象 x = x.prev; return x; } } 对于节点对象的指定插入，在实现上是较为复杂的，但原理是相似的 以上，是对于 LinkedList 的源码分析，大致是对于其中节点的作用的说明 正常元素添加、头部元素添加、指定位置元素添加] 值得注意的是，LinkedList 不存在初始大小，按需分配空间，不作预先处理 简单的理解，LinkedList 理论上不存在容量的限制，元素添加的效率较高 当然，每个对象由虚拟机分配的堆内存空间是有限的，不存在无限制的容量 它是基于链表实现的，在内存中，物理上存储是不连续的，通过节点，实现逻辑上的连续 目前，LinkedList 基于双向链表，而非双向循环链表 同时，LinkedList 也可以作为栈、队列使用，不局限于双向链表 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:13:24 "},"存储数据的容器/ArrayDeque类.html":{"url":"存储数据的容器/ArrayDeque类.html","title":"ArrayDeque","keywords":"","body":"基本使用 ArrrayDeque，实现了 Deque 接口、间接实现了 Queue 接口、 public class ArrayDeque extends AbstractCollection implements Deque, Cloneable, Serializable {} public interface Deque extends Queue {} ArrayDeque 是对于 ArrayList 的补充，二者都是的底层都是基于数组实现的 Deque，双端队列，可以对两端的元素做修改操作，且存在较高的效率 基于此，ArrayDeque在对于两端元素操作时，不会存在大量的元素移动 可以简单的理解，双端队列下的数组，首、尾操作方便，就好似一个 可循环数组 ArrayDeque 可以说是 ArrayList、LinkedList 的结合，达到了二者的均衡 ArrayList arrayList = new ArrayList<>(); long startTime = System.currentTimeMillis(); for (int i = 0; i LinkedList linkedList = new LinkedList<>(); long startTime2 = System.currentTimeMillis(); for (int i = 0; i ArrayDeque arrayDeque = new ArrayDeque<>(); long startTime1 = System.currentTimeMillis(); for (int i = 1; i 上述代码，分别是 ArrayList、LinkedList、ArrayQueue 对于头部元素插入的示例 可以很清晰的看出，ArrayList 在头部元素的插入上，表现不佳，极为耗时 而 ArrayDeque，它在元素的访问、添加操作上，都存在着较高的效率，表现适中 基于双端队列实现的ArrayDeque，在逻辑理解上，就好像是一个 循环数组 ArrayDeque可以从头部、尾部直接操作元素，首尾形成了闭环 现在，姑且将 ArrayDeque 看作是循环数组，它的首、尾元素修改方便 在源码分析时，注意 ArrayDeque、ArrayList 二者的区别 直接开始对于 ArrayDeque 的源码的分析，至于其中的常用方法，请翻阅 API 手册 初始化 // elements：存储容器元素的数组 transient Object[] elements; // 初始化，即默认存储数组的长度为 16 public ArrayDeque() { elements = new Object[16]; } 相对于 ArrayList 的初始化空数组，ArrayDeque 初始化的数组长度默认为 16 当然，ArrayDeque 中也是提供了有参构造，可以指定初始化时的默认数组长度 ArrayDeque(int numElements) {} 添加元素 public boolean add(E e) { addLast(e); return true; } 这是 ArrayDeque 的元素添加，注意 addLast(e);，元素默认添加至尾部 public void addLast(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; es[tail] = e; if (head == (tail = inc(tail, es.length))) grow(1); } ArrayDeque 的源码较为复杂，LinkedList 的节点类不过如此【狗头】 这里先分析源码的执行，也画一张图，理解理解 transient int tail;：尾部的元素的索引 + 1 transient int head;：头部元素的索引 理解双端队列 ArrayDeque，必须理解 tail、head 结合上图，可以很清晰的认识到二者的定位 head：指向头部元素的索引位置 tail：指向下一个尾部元素的索引位置，即当前尾部元素的索引 + 1 在双端队列中，头部元素不一定是存放在头部，也可能在中间位置 但是，head、tail 的值，是遵循常规的数组索引位置，自左向右递增 不清楚的部分概念，可以反复参考上述图例 现在，再看向ArrayDeque的元素添加，结合之前的理解，进行分析 public void addLast(E e) { if (e == null) throw new NullPointerException(); // 建立空数组，引用自 elements 数组 final Object[] es = elements; // 将添加的元素放至存储数组的头部位置 es[tail] = e; if (head == (tail = inc(tail, es.length))) grow(1); } static final int inc(int i, int modulus) { if (++i >= modulus) i = 0; return i; } private void grow(int needed) { // oldCapacity：存储当前数组的长度，即当前容量 final int oldCapacity = elements.length; // 扩容的新数组 int newCapacity; // 容量是否小于 64 // 若小于，扩容 2 个长度；若大于则扩容至 1.5 倍 int jump = (oldCapacity > 1); // MAX_ARRAY_SIZE：实际为 Integer.MAX_VALUE - 8; // jump 0) // 扩容新数组超出 Integer.MAX_VALUE - 8 // newCapacity 可以扩容的最大值 Integer.MAX_VALUE newCapacity = newCapacity(needed, jump); // es 数组拷贝，elements 拷贝，这一步已经完成了扩容 final Object[] es = elements = Arrays.copyOf(elements, newCapacity); // 核心：head 是否大于 0，即头部元素是否存在于最前端 if (tail // 扩容新数组，数据溢出时使用 private int newCapacity(int needed, int jump) { // oldCapacity 获得 elements 长度，并创建 int 变量 minCapacity final int oldCapacity = elements.length, minCapacity; // 当前数组长度 + 1，大于 Integer.MAX_VALUE - 8 if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE > 0) { // 这个真的可以满足吗，异常可以执行吗 if (minCapacity jump) return minCapacity; return (oldCapacity + jump - MAX_ARRAY_SIZE 好了，到这里可以看出 ArrayDeque 的具体扩容操作了 并且，也理解了双端队列，或者说循环数组的概念 这里，总结关于 ArrayDeque 的要点，不再结合相应源码做分析 索引 0 的元素，并非固定在最左侧，索引位置与实际位置不一致 删除头部、尾部元素，不会造成数组元素的整体变化 在 ArrayList 中，若删除头部元素，则所有元素前移一位，消耗极大 具体的双端队列，可以直接查看上述的图例，它的索引与位置的关系 ArrayDeque 不是根据索引位置获取数值，不存在 get()，注意与 ArrayList 的区别 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:14:11 "},"存储数据的容器/HashMap.html":{"url":"存储数据的容器/HashMap.html","title":"HashMap","keywords":"","body":"基本使用 对于 HashMap 的使用，主要是演示不同的操作方式，区别于 List 列表容器 具体的初始化、元素添加，会直接结合源码分析 对于更多的 API 使用，请参考官方提供的 API 手册 // 创建 HashMap 对象 HashMap hashMap = new HashMap<>(); // 添加元素 hashMap.put(0,\"A\"); hashMap.put(1,\"B\"); hashMap.put(2,\"C\"); hashMap.put(4,\"D\"); // 容器是否为空 System.out.println(hashMap.isEmpty()); // 取出元素 System.out.println(hashMap.get(2)); // 删除元素 hashMap.remove(3); // 获取所有的键 K System.out.println(Arrays.toString(hashMap.keySet().toArray())) 初始化 无参初始化 public HashMap() { // 负载因子的值默认为加载因子的值，0.75f this.loadFactor = DEFAULT_LOAD_FACTOR; } HashMap 的初始化容量也是空，再次声明，源码的阅读需结合具体的 JDK 版本 有参构造函数 public HashMap(int initialCapacity) { // 指定初始容量、负载因子 this(initialCapacity, DEFAULT_LOAD_FACTOR); } transient Node[] table;：负责存储键值对，以数组的形式 final float loadFactor;：负载因子 负载因子的大小，是 table 已经使用的容量的百分比 负载因子，在无参初始化时，设置为 0.75 加载因子，即负载因子默认为 0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f;：加载因子 int threshold;：容量阙值， 计算公式 ： table * loadFactor = threshold 节点类 HashMap 的哈希表，是由数组、单向链表组成 table 中直接存储一组数组，而数组中的每个元素可以拓展为一个单向链表 在 HashMap 中，存在两个节点类 Node、TreeNode 数组、单向链表中的元素，都是一个 Node 类，table 是 Node 类型的数组 当单向链表长度为 8 时，会转换为树形结构，此时会用到 TreeNode 源码分析，自此之后，会精简代码，完全版请直接参考 JDK 源码 // Node 节点类，以 K，V 键值对的形式存储元素 static class Node implements Map.Entry { // hash：该 Node 类在内存中的地址值 final int hash; final K key; V value; // next：指向下一个可能存在的 Node 节点 Node next; // 判断节点类对象是否相同 public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry e = (Map.Entry)o; if (Objects.equals(key, e.getKey()) && Objects.equals(value, e.getValue())) return true; } return false; } } static final class TreeNode extends LinkedHashMap.Entry { // 父节点 TreeNode parent; // 左节点 TreeNode left; // 右节点 TreeNode right; // 下一节点 TreeNode prev; // true 为红树；false 为黑树 boolean red; TreeNode(int hash, K key, V val, Node next) { super(hash, key, val, next); } } 为空扩容 HashMap 初始化时，默认 Node 数组为空，在添加第一个键值对时，存在默认扩容 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; // 若table数组为空，则该分支执行，默认扩容，核心为 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; } } final Node[] resize() { Node[] oldTab = table; // 此时数组为空，获得的是 0 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { } else if (oldThr > 0) // 初始阙值为零，即 table 为 null，该分支执行 // DEFAULT_INITIAL_CAPACITY = 1 [] newTab = (Node[])new Node[newCap]; // 数组扩容完毕 table = newTab; return newTab; } 在首次添加键值对时，将 table 的容量扩充为 16，负载因子占比 7.5，值为 12 计算 hash 值 每一个数组中的 Node 节点，都存在一个唯一的 hash 值 此数组所代表的单向链表中的Node节点，具有相同的hash值 // 添加元素，其中的 key 作为哈希值运算 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } // 将 key 通过一系列的运算，转换为 hash 值返回 static final int hash(Object key) { int h; // 若 key 为 0，则放置在数组 Node 节点的首位 // hash 值的计算，具体涉及到 hashCode()、按位异或、无符号右移 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } 以下是按位异或的使用，对于这二者，可以参考 语言基础 // 按位异或 `^`：相同为 0，不同为 1 System.out.println(16 ^ 7); /* 原码 16：00000000 00000000 00000000 00010000 原码 7：00000000 00000000 00000000 00000111 按位异或：00000000 00000000 00000000 00010111 */ 简单的理解，hashMap 的为空扩容，容量是 16，那么 hash 值就是 hashCode% 数组长度 hash 值可能存在重复，重复的键值对以单向链表的结构存储 元素添加 // 第一步：放入键值对 K，V public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } // 第二步：确定存储位置 /* hash：key 的哈希值 key：键 value：值 onlyIfAbsent：若为 true，则不更改原有值 evict：若为 false，table 处于创建模式 */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // tab：接收 table 数组； Node[] tab; Node p; int n, i; // 判断 table 数组中的某个位置是否为空，根据 hash 值选定 if ((p = tab[i = (n - 1) & hash]) == null) // newNode.. 创建常规的数组 Node 节点类 tab[i] = newNode(hash, key, value, null); // 若当前数组位置已存在元素，则向单向链表追加 else { Node e; K k; // 判断键是否相同 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 判断该节点是否是树节点，即由单向链表转为红黑树 else if (p instanceof TreeNode) // 添加为树节点 e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); else { // 依旧为单向链表，循环添加至链表的末尾位置 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { // 将传入的键值对存储为下一个节点 p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // 若键重复，则覆盖 Value 值 if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } } 链表转树 在一定的条件下，单向链表会被转换为红黑树结构 之后，新的键值对会以树节点的形式存储 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { else { else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { // 创建新的节点，此处已完成元素添加 p.next = newNode(hash, key, value, null); // 判断当前是否满足单向链表转树的条件 // TREEIFY_THRESHOLD = 8 if (binCount >= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } } } } } final void treeifyBin(Node[] tab, int hash) { int n, index; Node e; // 单向链表转为树结构，必须使得 table 长度大于 64，否则继续扩容 // MIN_TREEIFY_CAPACITY = 64 if (tab == null || (n = tab.length) hd = null, tl = null; do { TreeNode p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } 单向链表转为红黑树结构，必须满足两点 常规数组节点下的单向链表，长度必须大于等于 7 数组 table 的长度必须大于等于 64，即存在 63 个常规数组节点 数组扩容 table 的为空扩容，默认长度是 16 final Node[] resize() { Node[] oldTab = table; // 数组 table 是否为 null，即为空扩容 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 扩容至极限 Integer.MAX_VALUE if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 扩容为原来的二倍 else if ((newCap = oldCap = DEFAULT_INITIAL_CAPACITY) newThr = oldThr 0) newCap = oldThr; // 数组的为空扩容 else { newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap [] newTab = (Node[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j e; if ((e = oldTab[j]) != null) { // 新、老数组元素的拷贝迁移 } } // 返回扩容后的新数组 return newTab; } 对于 HashMap 容器的扩容，存在三点 为空扩容，扩容至 16 非空扩容，每次 扩容二倍 极限扩容，扩容至最大 Integer.MAX_VALUE 红黑自平衡 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:15:33 "},"存储数据的容器/HashSet.html":{"url":"存储数据的容器/HashSet.html","title":"HashSet","keywords":"","body":"基本使用 HashSet 的底层是 HashMap，而 HashMap 的底层是基于数组、单向链表实现的 基于此，HashSet 的修改、查询效率都比较高，但依旧是非线程安全的容器 HashSet 常用的 API 方法 boolean add(E e)：添加元素至集合中 void clear()：清空集合中的元素 Object clone()：HashSet实例的浅拷贝 boolean contains(Onject o)：是否包含指定元素 boolean isEmpty()：是否为空 Iterator iterator()：返回元素的迭代器 boolean remove(Object o)：移除指定的元素 int size()：返回数据元素的个数 HashSet hashSet = new HashSet<>(); // 添加元素 hashSet.add(1); hashSet.add(2); // 查看元素个数 System.out.println(hashSet.size()); // 删除元素 System.out.println(hashSet.remove(1)); // 是否为空 System.out.println(hashSet.isEmpty()); // 清空元素 hashSet.clear(); // 遍历元素 hashSet.add(5); hashSet.add(6); hashSet.add(7); for (Integer i : hashSet) { System.out.println(i); } 无序、不重复 之前有提到过，集合容器的存储是 无序、不重复 的 值得注意的是，无序是指 存储无序、取出无序；不重复也包括 NULL 值不重复 HashSet 的无序： HashSet 的无序，不是随机的无序，也不存在真正的随机数 HashSet 的无序，是数据元素根据各自的 哈希值 确定存储位置 数据元素的哈希值，经过运算，得到唯一的存储地址 简单的概括为一句话，HashSet 的无序，其元素存储地址是基于哈希值的运算结果 HashSet 的去重： HashSet 的去重，实际使用的是 equals() 方法 若两个数据元素的哈希值运算一致，则调用 equals() 二次判断 若 equals() 判断不通过，则该元素去重，不添加进容器内 若 equals() 判断通过，则该元素添加至单链表中，节点地址存储在数组中 对于 HashSet 的去重，其中的判定流程做详细说明 添加元素 A，其哈希值运算的存储地址，若不存在元素，则直接添加 若该存储地址已存在数据元素 B，则二者需要调用 equals() 再次判断 若这两个元素也通过了 equals() 的判断 那么，元素 A、B 将存在一个单向链表中，节点地址存储在元素 B 的数组索引位置 上述可以看出，HashSet 的存储特征，通过判定的相同元素，单独存储链表中 值得注意的是，HashSet 的链表是单向链表 对于自定义的 Java 类对象，一定要重写 hashcode()，这是去重判断的第一个依据 哈希值相同的元素，其存储位置相同，但是否存储需要经过 equals() 哈希值由类对象提供，HashSet 只负责重写 equals() 以包装类 Integer 为例，它已经重写 hashcode()，无法添加相同的数据元素 简单的概括为一句话，HashSet 的重复元素，会经历 equals() 的二次判定 对于 HashSet，只需要记住一点，理解了 HashMap，就理解了 HashSet 底层实现 之前有说过，HashSet 的底层是基于 HashMap 实现的 private transient HashMap map; public HashSet() { map = new HashMap<>(); } public boolean add(E e) { return map.put(e, PRESENT)==null; } 可以很清晰的看到，HashSet 在初始化、添加元素，都是使用的 HashMap 值得注意的是，HashSet 的值相当于 HashMap 的键，直接看源码 public boolean add(E e) { return map.put(e, PRESENT)==null; } 可以看出，HashSet 的元素作为了键，而 Map 的值则是一个固定的数 private static final Object PRESENT = new Object(); Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:17:33 "},"存储数据的容器/TreeMap.html":{"url":"存储数据的容器/TreeMap.html","title":"TreeMap","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:17:45 "},"存储数据的容器/TreeSet.html":{"url":"存储数据的容器/TreeSet.html","title":"TreeSet","keywords":"","body":"基本使用 TreeeSet 也是常用的集合，底层基于 TreeMap 实现，非线程安全的容器 与 HashSet 相比，明显的区别在于，TreeSet 可以 取出有序 TreeSet 的有序取出，可以基于两种方式、规则 通过元素自身实现比较规则 通过比较器指定比较规则 TreeSet的常用方法 boolean add(E e)：添加元素 E ceiling(E e)：返回集合中大于、等于给定元素的元素集 void clear()：清空元素 boolean contains(Object o)：是否存在指定元素 E first()：返回最小的元素，即第一个元素 SortedSet headSet(E toElement)：返回小于给定元素的部分元素视图 boolean isEmpty()：容器是否为空 更多常用方法，请参考官方 API 手册，谢谢 排序规则 在 TreeSet 中，数据元素取出时，默认由小向大、有序取出 值得注意的是，自定义类对象作为元素，必须存在排序规则 Java中，实现数据的大小比较，采用的是compareTo() public final class Integer extends Number implements Comparable {} public int compareTo(Integer anotherInteger) { return compare(this.value, anotherInteger.value); } 以上，是 Integer 类在实现 Comparable 接口，重写 compareTo 方法的源码 这就是 TreeSet 排序的第一个规则，通过元素自身的 接口实现、方法重写 TreeSet 的第一个比较方式，存在一个问题，需要在类的内部重写比较规则 而 TreeSet 的第二个比较规则，则可以将类对象元素的比较方式，抽离出来 TreeSet(Comparator comparator> 以上是 TreeSet 的一个有参构造，它可以用于接收一个比较器，进行排序 Comparator 接口，可以被实现，并重写其中方法，例如 int compare(T o1, T o2) 实现 Comparator 接口、重写 compare(T o1, T o2) 方法的类，可以作为比较器存在 此时，通过这种方式，数据元素自身，无须实现比较规则 这就是 TreeSet 排序的第二个规则，单独的类，实现 Comparator 接口、重写 compare(T o1, T o2) 方法，并作为比较器，传入 TreeSet 有参构造中 底层实现 TreeSet 的底层是基于 TreeMap 实现的，对于它的源码，仅作了解即可 private transient NavigableMap m; public TreeSet() { this(new TreeMap<>()); } public boolean add(E e) { return m.put(e, PRESENT)==null; } Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:19:45 "},"文件的输入输出/文件&目录.html":{"url":"文件的输入输出/文件&目录.html","title":"文件&目录","keywords":"","body":"文件的理解 在常规的理解中，文件指的是 doc、md、html、pdf，这些类型 而在计算机中，所有的文件都是二进制的数据，由 0、1 构成 Java 中的文件编程，则是对于文件的处理，主要是文件的传输，所以文件编程也可以说是 IO 流 流：输入、输出设备之间的传输通道，数据以流的形式传输 IO 流根据数据流的流向、传输的单位，可以划分为输入流、输出流；字节流、字符流 为了更具体的了解、区分 IO 流，这里采用字节、字符流讲述 以下，对于 IO 流的区分做简单的举例叙述 输入流 Input：从存储设备中读取数据到内存中 输出流 Output：从内存中写入数据到存储设备中 节点流：直接可以从数据源、目的地读写数据 FileInputStream、FileReader 处理流：不可以直接连接到数据源、目的地，通常用作处理其它的流BufferedInputStream、BufferedReader 字节流：以字节为单位获取数据，大多以 Stream 结尾，最高类为 InputStream、OutputStream，只可以读出写入文本类型的数据（详细了解char字符类型） 字符流：以字符为单位获取数据，大多以 Reader、Writer 结尾，最高类为 Reader、Writer，可以读出写入所有类型的数据（计算机中的数据一切皆字节byte） 文件、目录 File 类 File 类用于指代文件、文件夹，其中的构造方法，是用于建立文件、文件夹对象 字节、字符流实际上是对一个 File 类对象的操作，写入、读出数据 File 类的构造方法 File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File 实例 File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名，创建新的 File 实例 File(String parent, String child) ：从父路径名字符串和子路径名字符后才能，创建新的 File 实例 File(URL url) ：通过给定的 File:URL，转换为抽象路径名，创建新的实例 // 构造方法 1 根据另一个File类的路径，拼接新的路径 File fileP = new File(\"D:/\"); File fileC = new File(fileP, \"测试用例.txt\"); // 构造方法 2 直接写入路径 File file2 = new File(\"D:/测试用例.txt\"); // 构造方法 3 将一条完整的路径切分 File file3 = new File(\"D:/\", \"测试用例.txt\"); 文件操作 File 类中对于文件的常见用法 canRead() ：文件是否可读 canWrite() ：文件是否可写 createNewFile() ：文件是否存在，不存在则新建 exists() ：文件是否存在 getAbsolutePath() ：返回文件的绝对路径 delete() ：删除文件 File 的使用示例 File file = new File(\"D:\\\\TEMP\\\\A.txt\"); // 文件是否存在 if (file.exists()) { // 输出文件的名称 System.out.println(\"文件的名称：\" + file.getName()); // 输出文件的绝对路径 System.out.println(\"文件的绝对路径\" + file.getAbsolutePath()); // 输出文件的大小 System.out.println(\"文件的大小\" + file.length()); } else { try { // 文件不存在则新建文件 file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } 目录操作 对于文件目录的操作，大致为创建文件夹、删除文件夹、遍历内部文件 File 类的常用目录操作 boolean mkdir() ：创建文件目录 boolean mkdirs() ：创建文件目录，可以创建多级目录 boolean rename(File dest) ：重命名当前目录 File[] listFiles() ：获取目录下的所有子目录、文件 File[] listFiles(FilenameFilter filter) ：获取目录下的所有子目录、文件，可定义过滤条件 遍历某个目录下的 PDF 文件，不包括子目录内的 PDF 文件 File file = new File(\"D:\\\\PDF\"); File[] listFiles = file.listFiles(new FilenameFilter() { @Override // dir 父目录 name 子目录、文件 public boolean accept(File dir, String name) { return name.endsWith(\".pdf\"); } }); assert listFiles != null; for (File f : listFiles) { System.out.println(f.getName()); } 计算当前目录的总大小，包含其中的子目录、文件 public static void main(String[] args) { File file = new File(\"D:\\\\PDF\"); long files = getFiles(file); System.out.println(\"当前目录的总大小：\" + files); } public static long getFiles(File file) { long fileSize = 0; File[] listFiles = file.listFiles(); assert listFiles != null; for (File f : listFiles) { if (f.isFile()) { fileSize += f.length(); } else { fileSize += getFiles(f); } } return fileSize; } 计算当前目录下的所有 PDF 文件的总大小 public static void main(String[] args) { File file = new File(\"D:\\\\PDF\"); long files = getFiles(file); System.out.println(\"当前目录的总大小：\" + files); } public static long getFiles(File file) { long fileSize = 0; File[] listFiles = file.listFiles(new FilenameFilter() { @Override // dir 父目录 name 子目录、文件 public boolean accept(File dir, String name) { return name.endsWith(\".pdf\"); } }); assert listFiles != null; for (File f : listFiles) { System.out.println(f.getName()); } for (File f : listFiles) { if (f.isFile()) { fileSize += f.length(); } else { fileSize += getFiles(f); } } return fileSize; } 对于目录的删除，不可以直接删除非空的目录，也可以选择先使用上述递归的方式，清空其中的文件 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:26:43 "},"文件的输入输出/字节流.html":{"url":"文件的输入输出/字节流.html","title":"字节流","keywords":"","body":"InputStream、OutputStream 字节输入流 InputStream read() ：从输入流读取数据的下一个字节，若读取至末尾，则返回 -1 read(byte[] b) ：从输入流读取任意字节，并将它们存储到缓冲区 read(byte[] b, int off, int len) ：读取 len 字节的数据到一个字节数组 close() ：关闭输入流，并释放资源 字节输出流 OutputStream write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流 write(byte[] b, int off, int len) ：从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流 write(int b) ：将指定的字节写入此输出流 flush() ：刷新此输出流并强制任何缓冲的输出字节被写出 close() ：关闭此输出流并释放与此流相关联的任何系统资源 InputStream、OutputStream 作为字节流的抽象父类存在，具体的实现请看之后 FileInputStream、FileOutputStream 文件字节流 FileInputStream、OutputStream 文件字节流是 节点流，可以直接读、写数据 FileOutputStream ：写入数据到硬盘中 单字节写入 try { FileOutputStream stream = new FileOutputStream(\"D:/测试用例.txt\"); // main 程序的一次运行视为一次数据的写入 stream.write('H'); stream.write('W'); } catch (IOException e) { e.printStackTrace(); } 多字节写入，以字节数组的形式 try { FileOutputStream stream = new FileOutputStream(\"D:/测试用例.txt\"); String str = \"多个文字组成的字符串\"; // 将字符串转化为字节数组 byte[] bytes = str.getBytes(StandardCharsets.UTF_8); stream.write(bytes); } catch (IOException e) { e.printStackTrace(); } 单字节读取 try { FileInputStream stream = new FileInputStream(\"D:/测试用例.txt\"); int data; while ((data = stream.read()) != -1) { // 将整数再转换为对应的字符 System.out.print((char) data); } } catch (IOException e) { e.printStackTrace(); } 多字节读取 try { FileInputStream stream = new FileInputStream(\"D:/测试用例.txt\"); int data; byte[] bytes = new byte[1024]; while ((data = stream.read(bytes)) != -1) { // 输入出字符，一次最多输出 1024 System.out.print(new String(bytes, 0, data)); } } catch (IOException e) { e.printStackTrace(); } 文件字节流，实现文件拷贝 try { FileInputStream inputStream = new FileInputStream(\"D:/测试用例.txt\"); FileOutputStream outputStream = new FileOutputStream(\"D:/测试用例-12.txt\"); int data; byte[] bytes = new byte[1024 * 4]; while ((data = inputStream.read(bytes)) != -1) { // 写入数据的同时，打印内容 System.out.print(new String(bytes, 0, data)); outputStream.write(bytes, 0, data); } } catch (IOException e) { e.printStackTrace(); } ByteArrayInputStream、ByteArrayOutputStream 在之前的文件字节流中，存在一个问题，不能够一次性读取完文件数据 简单的理解，若一个字符正好是被分成了两个字节数组，则输出的时候就可能出现乱码 ByteArrayInputStream、ByteArrayOutputStream，则是为文件字节流设置了一个缓冲，可以存储每次读取的数据，最后一次输出完毕 try { FileInputStream inputStream = new FileInputStream(\"D:\\\\测试用例.txt\"); ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; int len; while ((len = inputStream.read(bytes)) != -1) { // 存储文件字节流读取的数据 arrayOutputStream.write(bytes, 0, len); } // 最后读取完毕时，一次输出 System.out.println(arrayOutputStream.toString(StandardCharsets.UTF_8)); } catch (IOException e) { e.printStackTrace(); } DateInputStream、DateOutputStream 之前的字节流中，只是以字节为单位，进行数据的读出、写入 DateInputStream、DateOutputStream 则是支持以不同的类型读出、写入，例如 int、long，设置是自定义的 Java 类 这里，一个 Java 类的实例对象为例，读出写入的方式 Person 类 public class Person { private String name; private Integer age; public Person() { } public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 将 Java 类对象写入到硬盘中 Person person = new Person(\"里斯\", 23); try { FileOutputStream outputStream = new FileOutputStream(\"D:\\\\测试用例.txt\"); DataOutputStream dataOutputStream = new DataOutputStream(outputStream); dataOutputStream.writeUTF(person.getName()); dataOutputStream.writeInt(person.getAge()); } catch (IOException e) { e.printStackTrace(); } 将 Java 类对象读取到内存中 try { FileInputStream inputStream = new FileInputStream(\"D:\\\\测试用例.txt\"); DataInputStream dataInputStream = new DataInputStream(inputStream); String name = dataInputStream.readUTF(); int age = dataInputStream.readInt(); System.out.println(name); System.out.println(age); } catch (IOException e) { e.printStackTrace(); } 可以很清晰的看到，字节流不仅仅是使用字节为单位进行传输的，也可以直接写入、读出 Java 类 这里面涉及到了Java对象的序列化机制，可以再被写入数据的文件中发现，文字是以乱码的形式表现的 BufferedInputStream、BufferedOutputStream BufferedInputStream、BufferedOutputStream 是字节缓冲输入流，可以为字节读出、写入提供缓冲区的支持 简单的理解，由字节缓冲流包装的文件字节流，可以将读出、写入的数据暂时缓存，最后再输出、写入 可能会觉得，缓冲字节流与字节数组流相似，但字节数组流内部并不存在缓冲区，只是功能效果上的类似 try { FileInputStream inputStream = new FileInputStream(\"D:/测试用例.txt\"); FileOutputStream outputStream = new FileOutputStream(\"D:/测试用例-12.txt\", true); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(outputStream); int data; byte[] bytes = new byte[1024]; while ((data = bufferedInputStream.read(bytes)) != -1) { System.out.print(new String(bytes, 0, data)); bufferedOutputStream.write(bytes, 0, data); } // 刷新缓冲区，否则数据不会被写入到硬盘中 bufferedOutputStream.flush(); } catch (IOException e) { e.printStackTrace(); } 值得注意的是，当数据写入到硬盘中时，必须刷新缓冲区 flush() 缓冲字节流的存在，使得无须频繁的读出、写入，但缓冲字节流无法直接操作数据，它是处理流，而非节点流 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:27:18 "},"文件的输入输出/字符流.html":{"url":"文件的输入输出/字符流.html","title":"字符流","keywords":"","body":"Reader、Writer 字符输入流 Reader Reader() ：创建一个新的字符流阅读器，其关键部分将在阅读器本身上同步 read() ：读一个字符 read(char[] cbuf) ：将字符读入数组 read(char[] cbuf, int off, int len) ：将字符读入数组的一部分 字符输出流 Writer Writer() ：创建一个新的字符流编写器，其关键部分将在编写器本身上同步 append(char c) ：将指定的字符追加到此writer append(CharSequence csq) ：将指定的字符序列追加到此writer append(CharSequence csq, int start, int end) ：将指定字符序列的子序列追加到此writer write(char[] cbuf) ：写一个字符数组 write(String str) ：写一个字符串 write(String str, int off, int len) ：写一个字符串的一部分 flush() ：刷新流 InputStreamReader、OutputStreamWriter InputStreamReader、OutputStreamWriter 可以将字节流转换为字符流，同时指定字符编码 try { InputStreamReader fileReader = new InputStreamReader(new FileInputStream(\"D:/测试用例.txt\")); OutputStreamWriter fileWriter = new OutputStreamWriter(new FileOutputStream(\"D:/测试用例-12.txt\"), StandardCharsets.UTF_8); int data; while ((data = fileReader.read()) != -1) { System.out.print((char) data); fileWriter.write((char) data); } fileWriter.close(); } catch (IOException e) { e.printStackTrace(); } FileReader、FileWriter 文件字符流 FileReader、FileWriter FileReader、FileWriter 值得注意的点是，只可以使用默认的字符编码，不可指定 FileReader 读取示例： try { FileReader fileReader = new FileReader(\"D:/测试用例.txt\"); int data; while ((data = fileReader.read()) != -1) { System.out.print((char) data); } } catch (IOException e) { e.printStackTrace(); } FileWriter 输入示例： try { FileWriter fileWriter = new FileWriter(\"D:/测试用例.txt\", true); fileWriter.write(\"追加的字符串\"); fileWriter.flush(); } catch (IOException e) { e.printStackTrace(); } FileReader、FileWriter 文件字符流 实现文件拷贝 try { FileReader fileReader = new FileReader(\"D:/测试用例.txt\"); FileWriter fileWriter = new FileWriter(\"D:/测试用例-12.txt\", true); int data; while ((data = fileReader.read()) != -1) { System.out.print((char) data); fileWriter.write((char) data); } fileWriter.close(); } catch (IOException e) { e.printStackTrace(); } CharArrayReader、CharArrayWriter CharArrayReader、CharArrayWriter 与字节数组字节流类似，不同的是的，单位是 char 字符，且可以指定字符编码 try { InputStreamReader fileReader = new InputStreamReader(new FileInputStream(\"D:\\\\测试用例.txt\"), StandardCharsets.UTF_8); CharArrayWriter charArrayWriter = new CharArrayWriter(); int data; char[] chars = new char[1024]; while ((data = fileReader.read(chars)) != -1) { charArrayWriter.write(chars, 0, data); } System.out.println(charArrayWriter.toString()); } catch (IOException e) { e.printStackTrace(); } StringReader、StringWriter StringReader、StringWriter 与 CharArrayReader、CharArrayWriter 类似，只是采用了 String、StringBuffer 替代了 char 数组，当然，本质上是一样的 try { InputStreamReader fileReader = new InputStreamReader(new FileInputStream(\"D:\\\\测试用例.txt\"), StandardCharsets.UTF_8); StringWriter stringWriter = new StringWriter(); int data; char[] chars = new char[1024]; while ((data = fileReader.read(chars)) != -1) { stringWriter.write(chars, 0, data); } System.out.println(stringWriter.toString()); } catch (IOException e) { e.printStackTrace(); } BufferedReader、BufferedWriter 同样是缓冲流，字符缓冲流的使用也需要注意刷新缓冲区 try { FileReader fileReader = new FileReader(\"D:\\\\测试用例.txt\"); BufferedReader bufferedReader = new BufferedReader(fileReader); int data; char[] chars = new char[1024]; while ((data = bufferedReader.read(chars)) != -1) { System.out.println(new String(chars, 0, data)); } } catch (IOException e) { e.printStackTrace(); } try { FileWriter fileWriter = new FileWriter(\"D:\\\\测试用例.txt\"); BufferedWriter bufferedWriter = new BufferedWriter(fileWriter); bufferedWriter.write(\"这是字符缓冲流，注意刷新缓冲区\"); bufferedWriter.flush(); } catch (IOException e) { e.printStackTrace(); } PrintWriter try { PrintWriter printWriter = new PrintWriter(\"D:\\\\测试用例.txt\", StandardCharsets.UTF_8); printWriter.write(\"这是打印输出流\"); printWriter.write(\"可以直接写入参\\n数名，也支持缓冲区\"); // 字符打印输出流是需要手动刷新缓冲区的 printWriter.flush(); } catch (IOException e) { e.printStackTrace(); } 标准流 Scanner 类是独自存在的一个Java类，它可以接收IO流数据，并解析输出 通常清空下，Scanner是接收的标准流，在Java的使用，System.out 就是标准流的一种，标准输出流 与之对应的是标准输入流，System.in ，常见的用法为：接收输入的数据 Scanner scanner = new Scanner(System.in); System.out.println(\"接收标准输入流，自键盘传入\"); String str = scanner.next(); System.out.println(str); Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:27:48 "},"文件的输入输出/文件类型.html":{"url":"文件的输入输出/文件类型.html","title":"文件类型","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"动态函数式编程/反射机制.html":{"url":"动态函数式编程/反射机制.html","title":"反射机制","keywords":"","body":"反射创建 反射，在程序运行时，获取类的属性、方法 详细些说，可以分为如下四点 获取实例对象所属的类 获取任意类中的成员变量、方法 调用实例对象的方法 构造类的实例对象 对于一个 Java 类文件，存在三种获取 Class 的方式 Object 类中定义的 getClass() 方法，通过实例对象调用 类名. class，直接调用 Class.forName()，根据类文件的所在路径 /* 第一种：实例化对象，调用 Object 类中定义的 getClass() 方法 */ ArrayList integers = new ArrayList<>(); System.out.println(integers.getClass().getName()); /* 第二种：通过类名. class，直接获取 */ System.out.println(ArrayList.class.getName()); /* 第三种：根据类文件所在的路径获取 */ System.out.println(Class.forName(\"java.util.ArrayList\")); 对于以上三种，推荐使用类名. class 或者 Class.forName() 值得注意的是，Class 类文件在虚拟机中只存在一份，三种方式获取的类文件是同一个 在 Class 类中，提供了大量的方法，对其中部分做简单介绍，其余请参阅官方 API 手册 String getName()：获取类文件的完整限定名 Field[] getFields()：获得类文件的公开属性 Field[] getDeclaredFields()：获取类文件的所有属性 Method[] getMethods()：获取类文件的公开方法 Method[] getDeclaredMethods()：获取类文件的所有方法 Class forName(String className)：根据限定名，获取、加载类文件 在使用 ArrayList 容器时，无法判断该容器的实例对象的实际容量 此时，就可以通过 Java 的反射机制，获取该实例对象内的容量属性 public static void main(String[] args) throws NoSuchFieldException { ArrayList integers = new ArrayList<>(); for (int i = 0; i arrayList) { try { // 获取指定的属性 Field elementData = arrayList.getClass().getDeclaredField(\"elementData\"); // 设置该属性字段为可访问 elementData.setAccessible(true); // 实际取值，返回 Object[] Object[] o = (Object[]) elementData.get(arrayList); return o.length; } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } return -1; } 以下，通过 ArrayList 类，演示反射的各部分操作 字段操作 Field[] getFields()：获取所有的、公开的字段。包括父类 Field[] getDeclaredFields()：获得所有的字段，不包括父类 Field getField(String name)：获得指定的、公开的字段 Field getDeclaredField(String name)：获得指定的字段 String getName()：获得字段的名称 boolean isAccessible(boolean flag)：是否具有该字段的访问权限 void setAccessible(boolean flag)：避开检查，获得该字段的访问权限 Object get(Object obj)：获得指定对象中的指定字段的值 void set(Object obj, Object value)：设置指定对象中的指定字段的值 ArrayList integers = new ArrayList<>(); Field defaultCapacity = integers.getClass().getDeclaredField(\"DEFAULT_CAPACITY\"); defaultCapacity.setAccessible(true); Object o = defaultCapacity.get(integers); System.out.println(o); for (Field field : integers.getClass().getDeclaredFields()) { field.setAccessible(true); System.out.println(field); } /* 10 private static final long java.util.ArrayList.serialVersionUID private static final int java.util.ArrayList.DEFAULT_CAPACITY private static final java.lang.Object[] java.util.ArrayList.EMPTY_ELEMENTDATA private static final java.lang.Object[] java.util.ArrayList.DEFAULTCAPACITY_EMPTY_ELEMENTDATA transient java.lang.Object[] java.util.ArrayList.elementData private int java.util.ArrayList.size private static final int java.util.ArrayList.MAX_ARRAY_SIZE */ 方法操作 Method[] getMethods()：获取类中所有的、公开的方法，包括父类 Method[] getDeclaredMethods()：获得类中所有的方法，不包括父类 Method getMethod(String name, Class... parameterTypes)：获得类中指定的、公开的方法 Method getDeclaredMethod(String name, Class... parameterTypes)：获得类中指定的方法 String getName()：获得方法的名称 void setAccessible(boolean flag)：是否具有该方法的访问权限 Object invoke(Object obj, Object... args)：调用该方法，传递参数列表 ArrayList integers = new ArrayList<>(); Method add = integers.getClass().getDeclaredMethod(\"add\", Object.class); add.setAccessible(true); add.invoke(integers, 120); System.out.println(integers.get(0)); for (Method method : integers.getClass().getMethods()) { System.out.println(method); } /* 120 public boolean java.util.ArrayList.add(java.lang.Object) public void java.util.ArrayList.add(int,java.lang.Object) public boolean java.util.ArrayList.remove(java.lang.Object) public java.lang.Object java.util.ArrayList.remove(int) public java.lang.Object java.util.ArrayList.get(int) public boolean java.util.ArrayList.equals(java.lang.Object) public int java.util.ArrayList.hashCode() public java.lang.Object java.util.ArrayList.clone() ............ */ 值得注意的是，若 invoke(Object obj, Object... args) 调用的是静态方法，则 obj 参数可以设为 null 实例对象 反射不仅可以访问、操作属性与方法，也可以实例实例化对象 T newInstance()：调用类的无参构造 类型判断 boolean isArray()：是否为数组 boolean isPrimitive()：是否为原始类型 boolean isInterface()：是否为接口 isEnum()：是否为美剧 isAnnotation()：是否为注解 isAnonymousClass()：是否为匿名内部类 isMemberClass()：是否为成员内部类 isLocalClass()：是否为本地类，即局部内部类 System.out.println(ArrayList.class.isArray()); System.out.println(ArrayList.class.isPrimitive()); System.out.println(ArrayList.class.isInterface()); System.out.println(ArrayList.class.isEnum()); System.out.println(ArrayList.class.isAnnotation()); System.out.println(ArrayList.class.isAnonymousClass()); System.out.println(ArrayList.class.isMemberClass()); System.out.println(ArrayList.class.isLocalClass()); /* false false false false false false false false */ 类的声明 int getModifiers()：获取类的修饰符，返回十六进制的文本数字 Class getSuperclass()：获取类继承的父类 Class[] getInterfaces()：获得类实现的接口 Annotation[] getDeclaredAnnotations()：获得类声明的注解 Annotation[] getAnnotations()：获得类声明的注解，包括父类 // getModifiers() 获取修饰符的十六进制的文本数字 PUBLIC = 0x00000001；ABSTRACT = 0x00000400 System.out.println(ArrayList.class.getModifiers()); System.out.println(AbstractList.class.getModifiers()); /* 1，1025 */ // 获取当前类的父类，Object 的父类为 null System.out.println(ArrayList.class.getSuperclass()); /* class java.util.AbstractList */ // 获取当前类实现的接口，返回值为数组 System.out.println(Arrays.toString(ArrayList.class.getInterfaces())); /* [interface java.util.List, interface java.util.RandomAccess, interface java.lang.Cloneable, interface java.io.Serializable] */ 内部类 Class[] getClasses()：获得所有公开的内部类、接口，包括父类 Class[] getDeclaredClasses()：获得所有的内部类、接口，不包括父类 Class getDeclaringClass()：若当前类为内部类，获取其最外侧外部类 Class getEnclosingClass()：若当前类为内部类，获取直接包含的外部类 Method getEnclosingMethod()：若为匿名、局部内部类，返回其中的方法 System.out.println(Arrays.toString(ArrayList.class.getClasses())); /* [] */ System.out.println(Arrays.toString(ArrayList.class.getDeclaredClasses())); /* [ class java.util.ArrayList$ArrayListSpliterator, class java.util.ArrayList$SubList, class java.util.ArrayList$ListItr, class java.util.ArrayList$Itr ] */ 类的加载 Class forName(String className)：根据全限定名，加载类文件 Class forName(String name, boolean initialize, ClassLoader loader)：加载类文件，并做一些设置 initialize：是否初始化代码块，默认为 true loader：类加载器，默认为 currentLoader 在之前反射的三种创建方式中，已经时间过了，这里不再演示 类加载器，暂时不必要了解，之后会有说明 在类的加载中，不支持原始类型，即无法使用 forName() Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:23:37 "},"动态函数式编程/注解原理.html":{"url":"动态函数式编程/注解原理.html","title":"注解原理","keywords":"","body":"注解概念 注解是 Java 的一个特性，使用 @ 字符开头 注解可以修饰代码元素，并为程序的编译、运行做出不同的作用 注解格式：public @interface 注解名称 {} 在 Java 中，提供了部分有效的内置注解、元注解 元注解是对于注解的注解，是用于对注解做说明 而大多数使用的注解，则是自定义注解，由第三方定义、提供 由此可见，注解主要分为三部分 内置注解，Java 内部提供的注解 元注解，对注解做说明的注解 自定义注解，多见于框架、库 内置注解 Java中提供的内置注解并不是很多，常见的内置注解有如下三种 @Override：定义该方法为子类重写的父类方法 @Deprecated：消除过时程序元素的标记 @SuppressWarnings：阻止程序的警告信息 以下通过代码，做简单的运用说明 /** 内置注解 @Deprecation 取消过时程序元素的废弃标记 内置注解 @SuppressWarnings 压制程序元素中的警告信息 all：压制所有类型 */ @Deprecated @SuppressWarnings(\"all\") public static void main(String[] args) throws Exception { /* 反射机制中的构造方法，已经被定义为过时方法，存在删除线标记 该ArrayList对象创建后未使用，存在警告、提示信息 */ ArrayList arrayList = ArrayList.class.newInstance(); } /** 内置注解 @Override 检查子类重写的父类方法 */ @Override public String toString() { return super.toString(); } 对于这三种内置注解，其中 @Override 使用的是最为广泛，而 @Deprecated、@SuppressWarnings 也有着不小的应用场景 其中，@SuppressWarnings 可以取代 @Deprecated 的作用，写作：@SuppressWarnings(\"deprecation\") 对于@SuppressWarnings详细的使用与抑制警告的累心给，可以自行摸索 当然，Java 中还存在着其它的内置注解，这三种只是常用的 其它的内置注解还有 @FunctionalInterface：声明接口为函数式接口 @SafeVarargs：抑制 unchecked 警告 内置注解的使用，并不复杂，最常用的还是自定义注解 元注解 元注解，是注解的注解，对注解做注解说明 @Retention：设置注解的有效期 @Documented：注解元素包含到JavaDoc中 @Target：该注解可以定义的位置 @Inherited：声明该注解可以继承 以下，简单的介绍元注解的使用 @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } public enum ElementType { TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_PARAMETER, TYPE_USE, MODULE } public enum RetentionPolicy { SOURCE, CLASS, RUNTIME } 上述三份代码示例，是对于 @Override 注解的分析 @Override 注解，存在两个元注解 @Target()、@Retention() @Target(ElementType.METHOD)：定义于方法体上 @Retention(RetentionPolicy.SOURCE)：存在于 Java 源代码 ElementType、RetentionPolicy 都是枚举类 此时，通过 @Override 可以看出，元注解可以定义注解的位置、有效阶段 自定义注解 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface Ann { int value() default 0; } @Ann(value = 12) public static void main(String[] args) { } Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:23:27 "},"没落的那些时光/JDBC.html":{"url":"没落的那些时光/JDBC.html","title":"JDBC","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"没落的那些时光/Servlet.html":{"url":"没落的那些时光/Servlet.html","title":"Servlet","keywords":"","body":"简介 Servlet（Server Applet），全称 Java Servlet。是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。 Servlet 运行于支持 Java 的应用服务器中。从实现上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。 最早支持 Servlet 标准的是 JavaSoft 的 Java Web Server。此后，一些其它的基于 Java 的 Web 服务器开始支持标准的 Servlet。 上述文字，引用自维基百科，对于 Servlet，在后续的介绍中可以充分理解 入门 这里，将做 Servlet 的入门介绍，了解 JavaEE 中的 WEB 方向的基石是如何工作的 Servlet 应用搭建 对于 Servlet 的应用搭建，采用 Maven 的方式，IDEA 在新版本中取消了 JavaEE 应用的直接构建 第一步：建立空的 Mavne 项目，引入 Servlet 依赖 javax.servlet javax.servlet-api 4.0.1 第二步：在 src/main 目录下新建 webapp 目录，与 java 目录在同一级，其中 resources 目录可以删除 src main java webapp 第三步：在 webapp 目录下新建如下内容，并写入 xml 信息，并根据 IDEA 的右下角提示，完成构建 webapp WEB-INF web.xml index.jsp Archetype Created Web Application Hello World! 第四步：部署 Tomcat，配置路径信息等，位于 IDEA 右上角 第五步：新建 Java 类，细节如下，核心为继承 HttpServlet、重写 service()、注解 @WebServlet() @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println(\"...\"); } } 此时，启动 Tomcat，进入配置的 URL 路径，可以看到控制台打印的信息 Servlet 实现原理 Servlet 是位于服务端的程序，普通的 Java 类可以继承 HttpServlet，转换为一个 Servlet 程序 可以看出，Servlet 程序不存在 main 方法，它是被动的接收请求与返回响应 简单的理解，Servlet 程序部署在 WEB 应用服务器上，例如主流的 Tomcat，由 Tomcat 管理 Servlet 程序 现在，通过 IDEA 打开 HttpServlet 的继承图，可以看出 HttpServlet 类继承了 GenericServlet 类 GenericServlet 类又实现了 Servlet 接口 也就是说，Servlet 实际上是 Java 中的一个接口、一种规范 而为什么是继承 HttpServlet，则是因为，HttpServlet 基于 Serlvet 接口规范、提供了大量的可用方法 简单的理解为，ArrayList 作为 Collection 接口的具体实现类，提供了大量的使用方法 至于服务端、WEB 端通信的 HTTP 协议，则可以理解为容器的数据结构，可以单独去学习，Servlet 的学习不必要深究 HTTP Servlet 生命周期 一个 Servlet 程序，存在着生命周期，而 Servlet 的生命周期，实质上是交由 WEB 容器负责管理 void init(ServletConfig var1) throws ServletException; void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; void destroy(); 上述为 Servlet 接口中定义的部分抽象方法，代表着 Servlet 程序的生命周期 对于 Servlet 的生命周期，分为三个阶段 初始阶段：请求到达该 Servle 程序，则该 Servlet 程序实例化对象，仅且执行一次 服务阶段：此阶段不断地进行请求与响应，可执行多次 销毁阶段：Servlet 程序销毁，仅且执行一次 请看下方示例，结合 Tomcat 控制台的日志信息 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override public void init(ServletConfig config) throws ServletException { System.out.println(\"Servlet 初始化\"); } @Override public void service(ServletRequest req, ServletResponse res) { System.out.println(\"Servlet 服务中\"); } @Override public void destroy() { System.out.println(\"Servlet 已销毁\"); } } 此时，运行 Tomcat，并访问该路径，则可以看到初始、服务的信息被打印，再关闭 Tomcat，可以看到关闭前 Servlet 程序的销毁信息 请求与响应 对于 Servlet 程序，它的主要职责就是接收请求数据、返回响应数据，对应的方法是 HttpServletRequest、HttpServletResponse HttpServlet 是 Servlet 的实现类，基于 HttpServlet 讲解 Servler 程序 HttpServletRequest 请求 基本使用 HttpServletRequest 负责接收 WEB 端传递到服务端的数据，部分常用的方法有 getRequestURL()：获得客户端发送请求时的完整的 URL getRequestURI()：获取项目中的相对 URL getQueryString()：获取请求的参数 getParameter()：获得指定的参数 getMethod()：获取请求的方式 getprotocol()：获取 HTTP 版本号 对于更多更具体的参考，请查阅 JavaEE API 手册 请求乱码 若传递的参数中存在中文，就可能存在乱码的问题，原因在于 Tomcat 的默认编码 对于请求的方式，分为两种 GET 请求、POST 请求，值得注意的是，高版本的 Tomcat 不存在 GET 请求乱码 当然，若使用的是 getQueryString() 方法，依旧会乱码，这里指的请求参数获取是指 getParameter() 方法 现在，重点解决的是 POST 请求参数乱码，方法如下 // 根据 UTF-8 编码进行字符的解码 req.setCharacterEncoding(\"utf-8\"); 这里提一点，若在 JSP 页面传递数据，必须做以下的声明标签，否则会传递中文的 GDK 编码，这不是乱码 请求转发 在接收请求时，可以将数据转发至其它的 Servlet 程序进行处理，下方为具体代码示例 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); String userName = req.getParameter(\"userName\"); req.getRequestDispatcher(\"test01\").forward(req, resp); } } @WebServlet(\"/test01\") public class Servlet01 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); System.out.println(\"成功接收转发的请求：\" + req.getParameter(\"userName\")); } } 此时，第一个 Servlet 程序不再打印参数，请求被转发到第二个 Servlert 程序 值得注意的是，请求转发是服务端的行为，页面的地址栏并不会发生变更 request 域对象 在上述的请求转发中，可以看出，第二个 Servlet 并未获得参数，却可以打印参数，原因在于：一次请求转发中的 Servlet 程序共享一个 Request 作用域 仔细观察代码，在做请求转发时，除了指定转发的地址，也传入了 request、response 两个对象 除了从页面请求中获得的数据，也可以手动往 request 作用域中添加数据 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); req.setAttribute(\"hxd\",\"hxd,gys!!!\"); req.getRequestDispatcher(\"test01\").forward(req, resp); } } @WebServlet(\"/test01\") public class Servlet01 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); System.out.println(req.getAttribute(\"hxd\")); } } 对于 request 作用域存、取数据，用到了两个 API 方法 req.setAttribute(String str, Object obj)：存储数据，以类似键值的形式 req.getAttribute()：读取数据，根据存储的键 HttpServletResponse 响应 基本使用 现在，介绍response对象，用于响应WEB端的请求，返回数据 对于数据的响应，存在两种方式：以字符形式响应、以字节形式响应 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 以字符流的形式响应数据 PrintWriter writer = resp.getWriter(); writer.write(\"123\"); // 以字节流的形式响应数据 ServletOutputStream stream = resp.getOutputStream(); stream.write(\"456\".getBytes()); } } 注意，两种响应的方式，不可以同时使用，response 对象只可以使用一种方式做响应数据 第二种响应方式会被无视，也可能导致异常问题 当然，一种方式可以做多次数据响应，如下所示 PrintWriter writer = resp.getWriter(); writer.write(\"123\"); writer.write(\"456\"); 响应乱码 同样的，在使用中文做响应数据时，也会出现乱码的问题，解决方法如下 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException { // 指定服务端编码 resp.setCharacterEncoding(\"UTF-8\"); // 指定客户端解码 resp.setHeader(\"Content-Type\",\"text/html;charset=UTF-8\"); PrintWriter writer = resp.getWriter(); writer.write(\"好兄弟\"); } } 需要注意的是，必须同时指定服务端、客户端的编码、解码方式，做到保持一致 重定向 重定向，与请求转发不同，它是将页面重定向到另一个页面 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.setCharacterEncoding(\"UTF-8\"); resp.setHeader(\"Content-Type\",\"text/html;charset=UTF-8\"); resp.sendRedirect(\"index.jsp\"); } } Title 首页吧！ 此时，任何页面发送请求至该 Servlet 程序，都将被重定向到另一个页面 简单的理解，重定向是客户端行为，地址栏也会发生变更 请求转发与重定向 在上述的请求、响应中介绍了请求转发与重定向，这里做统一的比较 请求转发是发生在服务端的行为，不对地址栏产生影响，同时， 仅可以在服务端内部进行请求转发 重定向是发生在客户端的行为，服务端仅作为中介，会对地址栏产生影响，且可以跳转至互联网的任意位置 会话管理 在之前的请求响应中，服务端不会对客户端做任何的记录 会话管理，即服务端对客户端的访问做状态处理，通过两个技术 Cookie、Session Cookie 存取 Cookie Cookie 是由服务端创建的，保存在客户端的会话信息，示例如下 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { // 新建一个 Cookie 对象 Cookie cookie = new Cookie(\"userName\", \"好兄弟\"); // 将 Cookie 对象响应回客户端 resp.addCookie(cookie); } } 此时，打开浏览器控制台，可以在存储中看到响应的 Cookie 数据 同样的，服务端也可以读取客户端保存的 Cookie 数据 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { // Java 中仅支持以数组的形式获取 Cookie Cookie[] cookies = req.getCookies(); for (Cookie cookie : cookies) { System.out.println(cookie.getName()); System.out.println(cookie.getValue()); } } } Cookie 失效 对于 Cookie 会话，它是存在着默认的有效时间，不指定则由存储的浏览器决定 对于 Cookie，服务端可以指定它的有效时间，存在三种情况，设置 Cookie 时间的方法是 setMaxAge() // 单位为秒，即该 Cookie 有效期为十秒 cookie.setMaxAge(10); // 负整数，该 Cookie 存活至浏览器关闭 cookie.setMaxAge(-1); // 设置为零，即删除该 Cookie，直接失效 cookie.setMaxAge(0); 值得注意的是，Cookie 设置为零，只对指定了具体存活时间的 Cookie 有效 另外，若在 Cookie 的有效期内，浏览器关闭，该 Cookie 并不会直接失效，只会等待时间的到期 对于存活至浏览器关闭的 Cookie，无法通过服务端使其失效 Cookie 路径 对于 Cookie 数据的存储，可以为其指定路径，大致可以分为四类 设置 Cookie 路径的方法为 setPath() 第一类：服务端的任何 Servlet 程序都可以获取 Cookie 对象 setPath(\"/\") 第二类：创建该 Cookie 的项目路径的 Servlet 程序可以获得，这是默认情况 setPath(\"/创建的路径\") 第三类：指定项目路径的 Servlet 程序可以获得该 Cookie 对象 setPath(\"/指定的其它路径\") Cookie 细节 对于 Cookie 的使用，需要注意几点 第一，Cookie 的键不可以，也不应该为中文，这可能会导致错误 第二、同名 Cookie 的存储，会默认覆盖之前的 Cookie 第三，Cookie 存在大小的限制，一般只用于存储重要的数据信息 第四、Cookie 存在于浏览器中，存在被浏览器禁用的可能 Session Session 使用 Session是特殊的Cookie，在用法上大致相同 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { // 获取Session对象，若不存在则新建 HttpSession session = req.getSession(); // 获取Session对象的唯一标识 System.out.println(session.getId()); // 获取Session对象的创建时间 System.out.println(session.getCreationTime()); // 获取Session对象的最后访问时间 System.out.println(session.getLastAccessedTime()); // 判断该Session是否是新的对象，即服务端是否记录了该Session System.out.println(session.isNew()); } } 对于 Session 的唯一标识 JSESSIONID 需要格外注意，它存储于浏览器中，标识唯一 Session 值得注意的是，对于 JSESSIONID 的无意义修改、删除，会使得服务端认为不存在 Session 对象，则会新建一个 Session 另外，被覆盖的 JSESSIONID 依旧被记录在服务端中，此时，若将最开始的 JSESSIONID 写入，则服务端不会认为这是一个新的 Session 对象 作为特殊的 Cookie，Session 也存在有效期，默认为为浏览器关闭，即 Cookie 有效期设置为 - 1 Session 域对象 与 request 类似，Session 也存在特定的域对象 Session 域对象，仅在一次 Session 会话中有效，数据不会在多个 Session 中共享，这与 request 一次请求中共享相似 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { HttpSession session = req.getSession(); session.setAttribute(\"userName\", \"里斯\"); System.out.println(session.getId()); System.out.println(session.getAttribute(\"userName\")); } } 可以通过 removeAttribute() 在 Session 域对象中移除指定的数据 Session 销毁 对于 Session 对象的销毁，存在着多种方式 第一种：依赖 Tomcat 应用服务器中默认 Session 失效时间 打开 Tomcat 中的 conf 目录，在其中的 web.xml 存在以下的配置 30 第二种：指定 Session 对象的默认有效时间 调用方法 getMaxInactiveInterval()，单位为秒 第三种：手动直接销毁，使用较多 调用方法 invalidate()，直接销毁 Session 对象 第四种：浏览器关闭 当前浏览器关闭，Session 会话销毁 ServletContext 对象 ServletContext 概念 每一个 Tomcat 应用服务器启动的 WEB 应用中，仅且仅存在一个 ServletContext 对象，也可以称为 Application 对象，它的作用域是整个 WEB 应用程序的运行期间 当一个应用程序创建时，ServletContext 对象被创建；当一个应用程序销毁时，ServletContext 对象被销毁 对于 ServletConetxt 对象，它存在两大作用 实现全局范围内的数据共享 存储当前应用程序的相关信息 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { // 获取当前应用服务器的信息 System.out.println(getServletConfig()); // 获取当前 WEB 应用程序的信息 System.out.println(getServletContext()); // 获取当前 Servlet 程序的全限定名 System.out.println(getServletName()); } } 由于 ServletContext 对象是在服务器启动时创建，全局作用域的对象，可以直接调用该对象的对应方法 ServletContext 对象的获取方式 对于ServletContext对象，存在四种获取的方式，上述的示例已经介绍了一种，直接获取ServletContext对象 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { // 直接获取 ServletContext servletContext = getServletContext(); // request 对象获取 ServletContext servletContext1 = req.getServletContext(); // session 对象获取 ServletContext servletContext2 = req.getSession().getServletContext(); // ServletConfig 对象获取 ServletContext servletContext3 = getServletConfig().getServletContext(); } } ServletContext 域对象 ServletContext 也可以作为域对象，是哦也能够方法大致与 request、session 相同 @WebServlet(\"/test\") public class Servlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { ServletContext servletContext = req.getServletContext(); servletContext.setAttribute(\"userName\", \"里斯\"); System.out.println(servletContext.getAttribute(\"userName\")); servletContext.removeAttribute(\"userName\"); } } 可以看出，使用方法上一致 Servlet 三大域对象 现在，Servlet 中一共存在了三个域对象，request 域对象、session 域对象、ServletContext 域对象 这三个域对象，其中以 request 的作用域最小，仅在一次请求转发中有效；而 ServletContext 作用域最大，直到服务器关闭才会失效 当然，由于在真正的项目开发中，服务器长期处于开启状态，需要格外注意域对象的使用，不可让无意义的数据长时间占据内存 基于此，应当使用作用域较小的 request 域对象、session 域对象，对于 ServletContext 域对象需要避免使用 小结 Servlet 作为 JavaEE 的一种规范，在技术层面上，已经落后于时代，现在大多使用基于 Servlet 规范封装的其它技术，例如 Spring Servlet。并且，Servlet 原始的文件上传下载较为简陋，也大多可以使用 Apache 提供的工具包做替代 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-06 10:37:18 "},"没落的那些时光/JSP.html":{"url":"没落的那些时光/JSP.html","title":"JSP","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"令人敬畏的春天/初识Srping生态.html":{"url":"令人敬畏的春天/初识Srping生态.html","title":"初识 Spring 生态","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"令人敬畏的春天/IOC控制反转.html":{"url":"令人敬畏的春天/IOC控制反转.html","title":"IOC 控制反转","keywords":"","body":"IOC 简述 控制反转（英语： Inversion of Control，缩写为 IoC ），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称 DI），还有一种方式叫 “依赖查找”（Dependency Lookup） 早在 2004 年，Martin Fowler 就提出了 “哪些方面的控制被反转了？” 这个问题。他总结出是依赖对象的获得被反转了，因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度 耦合并且难以维护和调试。 Class A 中用到了 Class B 的对象 b，一般情况下，需要在 A 的代码中显式的 new 一个 B 的对象。 采用依赖注入技术之后，A 的代码只需要定义一个私有的 B 对象，不需要直接 new 来获得这个对象，而是通过相关的容器控制程序来将 B 对象在外部 new 出来并注入到 A 类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如 XML）来指定。 实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类 A 的实例创建过程中即创建了依赖的 B 对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。 依赖注入有如下实现方式： 基于接口。实现特定接口以供外部容器注入所依赖类型的对象。 基于 set 方法。实现特定属性的 public set 方法，来让外部容器调用传入所依赖类型的对象。 基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。 基于注解。基于 Java 的注解功能，在私有变量前加 “@Autowired” 等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了 public 的 set 方法，但是因为没有真正的 set 方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为 set 方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。 依赖查找更加主动，在需要的时候通过调用框架提供的方法来获取对象，获取时需要提供相关的配置文件路径、key 等信息来确定获取对象的状态 上述介绍引用自维基百科，对于 IOC 的描述极为清晰！ 入门示例 第一步：先构建一个标准的 Maven 项目，导入 Spring 的核心依赖 org.springframework spring-context 5.2.15.RELEASE 为了方便测试，也可以选择再导入 junit 依赖 junit junit 4.13.2 test 第二步：创建 Java 的实体类 Person，之后该 Java 类的对象实例化交由 Spring 管理 public class Person { private String name; private Short age; public void setName(String name) { this.name = name; } public void setAge(Short age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 第三步：在新建的 Maven 项目的资源目录下，新建 Spring 的配置文件 SpringBeans.xml，并将之前的 Person 类注入为 Bean 对象 第四步：编写测试代码 @Test public void get() { ApplicationContext context = new ClassPathXmlApplicationContext(\"SpringBeans.xml\"); Person person = (Person) context.getBean(\"person\"); person.setName(\"里斯\"); person.setAge((short) 16); System.out.println(person); } 至此，可以看到 Spring 中 IOC 的作用：接管类的对象实例化，统一配置 这里，简单介绍下之前的几个步骤 SpringBeans.xml 是 IOC 容器工厂，其中负责配置需要实例化的类对象，通过 XML 的形式 bean 对象存在的两个属性，class 是类的全限定名，id 是 bean 对象的唯一标识，多为类名首字母小写 ClassPathXmlApplicationContext 是通过相对路径读取 Spring 的配置文件位置，根目录为 Maven 的资源目录 模拟 IOC 容器 IOC 是如何接管对象实例化的？其实很简单，在之前的反射机制中，存在 通过类的全限定名，完成对象的实例化创建 现在，简单的模拟一个 IOC 容器的实现，大致思路如下 新建配置文件，进行 XML 解析，获取 id、class 属性 对于获得的 class 属性，通过反射机制实例化对象 通过 id，再获取对应的实例化对象，调用相关方法 第一步：导入相关的 Maven 依赖，无须 Spring 依赖 dom4j dom4j 1.1 jaxen jaxen 1.2.0 junit junit 4.13.2 test 第二步：编写相关的配置文件 SpringBeans.xml 第三步：新建实体类、Bean 类 public class Person { private String name; private Short age; public void setName(String name) { this.name = name; } public void setAge(Short age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } public class Bean { /** bean 对象的 id */ private String id; /** bean 对象的 class，写做 clazz，避免关键字的使用 */ private String clazz; public Bean() { } public Bean(String id, String clazz) { this.id = id; this.clazz = clazz; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getClazz() { return clazz; } public void setClazz(String clazz) { this.clazz = clazz; } } 第四步：编写读取配置文件的 Java 类 ClassPathXmlApplicationContext public class ClassPathXmlApplicationContext { private List bean; private Map beans = new HashMap<>(); /** * 读取配置文件 */ public ClassPathXmlApplicationContext(String fileName) { /* 解析配置文件，获取其中定义的 Bean 对象，存入 List */ this.parseXml(fileName); /* 通过反射，完成对象的实例化，存入 Map */ this.instanceBean(); } public Object getBean(String id) { return beans.get(id); } /** * 获取之前的 Bean 对象列表，实例化其中的类 */ private void instanceBean() { if (bean != null && bean.size() > 0) { for (Bean bean : bean) { String id = bean.getId(); String clazz = bean.getClazz(); try { /* 反射完成对象的实例化 */ Object o = Class.forName(clazz).newInstance(); /* 以 id、实例对象的形式存储 */ beans.put(id, o); } catch (Exception e) { e.printStackTrace(); } } } } private void parseXml(String fileName) { /* 获取 XML 解析器 */ SAXReader saxReader = new SAXReader(); /* 获取配置文件的路径 */ URL resource = this.getClass().getClassLoader().getResource(fileName); try { /* 解析配置文件 */ Document read = saxReader.read(resource); /* 解析 XML 标签 */ XPath xPath = read.createXPath(\"beans/bean\"); List nodes = xPath.selectNodes(read); if (nodes != null && nodes.size() > 0) { /* 需要时，完成实例化 */ bean = new ArrayList<>(); for (Element el : nodes) { /* 获取标签的属性值 */ String id = el.attributeValue(\"id\"); String aClass = el.attributeValue(\"class\"); /* 存入 Bean 对象 */ Bean beans = new Bean(id, aClass); /* 存入容器 */ bean.add(beans); } } } catch (DocumentException e) { e.printStackTrace(); } } } 这一步较为复杂，其中如何解析 XML 文件暂不介绍。可以看出，获取 Java 类的 class 属性，即全限定名，反射创建实例对象 第五步：测试该 IOC 容器的模拟实现、 @Test public void get(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"SpringBeans.xml\"); Person person = (Person) context.getBean(\"person\"); person.setName(\"里斯\"); person.setAge((short) 12); System.out.println(person); } 至此，对于 IOC 容器的模拟实现有了一定的认识，尽管看起来极为粗糙。却已经实现了类的实例化，不再通过关键字 new，完成 对象控制权的反转 配置文件加载 在之前，通过 ClassPathXmlApplicationContext 基于相对路径加载配置文件。在 Spring 中，提供了其它的加载文件的方式 ApplicationContext 接口作为配置文件加载类的父接口存在。其下定义了两种主要的实现类 ClassPathXmlApplicationContext：相对路径加载，例如Maven项目的资源目录 FileSystemXmlApplicationContext：绝对路径加载，文件在当前计算机中的全路径 另外，当需要同时加载多个配置文件时，也存在两种方式 // 第一种：传入多个参数即可 ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); Bean 实例化 Spring IoC 容器通过 Bean 对象，可以完成 Java 类的实例化操作，存在三种实例化方式 无参构造实例化 静态工厂实例化 实例工厂实例化 bean 对象默认使用无参构造进行实例化，不做介绍 静态工厂方法实例化 工厂设计模式的使用 第一步：新建对应的静态工厂类 public class StaticFactory { private static Person person = new Person(); public StaticFactory() { } public static Person createPerson() { return person; } } 第二步：新建对应的 bean 对象 第三步：新建测试方法 @Test public void get02() { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\"beans.xml\"); Object staticFactory = beanFactory.getBean(\"staticFactory\"); System.out.println(staticFactory); } 对于静态工厂实例化，很好理解。在静态工厂类中新建私有静态成员属性，该属性为对应的 Java 类，同时新建相应的静态方法，以返回新建的静态属性，即 Java 类的实例对象 在 bean 对象中，需要将 class 属性更换为静态工厂类的全限定名。并且添加 factory-method 属性，属性值为静态工厂类中的对应静态方法 实例工厂方法实例化 实例工厂方法相对复杂 第一步：取消之前的静态工厂类的静态方法，变更为实例方法 public Person createPerson() { return person; } 第二步：新建实例工厂类 public class InstanceFactory { private StaticFactory staticFactory = new StaticFactory(); public InstanceFactory() { } public StaticFactory createStaticFactory() { return staticFactory; } } 第三步：新建实例工厂类的 bean 对象，并修改之前的静态工厂类的 bean 对象 第四步：编写测试代码 @Test public void get03() { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\"beans.xml\"); Object staticFactory = beanFactory.getBean(\"instanceFactory\"); System.out.println(staticFactory); } 实例工厂实例化，是通过托管静态工厂中的非静态方法实现的，细节请参考 Spring 官方文档 小结 上述，介绍了除无参构造实例化以外的两种工厂实例化方法。一个工厂类中可以存在多个工厂方法，分别对应独立的 bean 对象，但相对而言，工厂实例化使用的场景并不是很多。 DI 依赖注入 DI 依赖注入，就是为 bean 对象注入属性值，一个 Java 类的实例对象属性赋值被称为 DI 依赖注入 对于依赖注入的方式吗，存在两种 通过 set 方法注入属性 通过有参构造注入属性 在以前的开发中，也是通过以上的两种方式完成实例对象的属性注入，这里，只是交由 IoC 容器管理 set 注入 set 注入，必须使 Java 类存在对应的 set 方法 第一步：新建 Java 类，生成 set 方法 public class Person { private String name; private Integer age; ...... public void setName(String name) { this.name = name; } public void setAge(Integer age) { this.age = age; } ...... } 第二步：通过 bean 对象完成 DI 属性注入 第三步：新建测试方法 @Test public void get() { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\"beans.xml\"); Object person = beanFactory.getBean(\"person\"); System.out.println(person); } 此时，可以发现，bean 对象中存在属性，不再为 null 构造注入 构造注入，指的是有参构造，需要注意其中的形式参数 对于构造注入，XML 标签由 property 变为了 constructor-arg，其余大致相同 小结 对于 DI 依赖注入，在官方文档还有更多的细节介绍 set 注入时，根据属性的类型，如 list、map，存在不同的写法 构造注入时，可以将注入的属性与形参建立联系，通过形参的索引位置 可以将 value 属性更换为 ref 属性，表示引用其它的 bean 对象，对应的是 Java 类的引用类型属性 这里，不做这些过于细节的介绍，大多数很少使用，例如构造的索引匹配 对于 set、有参构造的注入方式，存在着各自的弊病，这里先留作日后介绍 自动化装配 在之前的 DI 依赖注入中，需要手动完成，这样过于繁琐，Spring 中支持通过注解的形式完成自动化装配 注解配置 对于 Spring 中的注解支持，需要做如下的配置 上述是摘自 Spring 官方文档中的配置说明 添加相应的命名空间 xmlns:context... 开启注解 必须这样，Spring 中才可以支持注解的使用，而自动化装配就是通过注解形式实现的 @Autowired 对于注解，应该是较为熟悉，例如注解的可应用位置等 @Autowired 注解，应用的场景较多，这里应用于字段属性。接下来，介绍注解对于自动化装配的实现 第一步：新建 School 类，作为 Person 类的引用属性存在 public class School { } 第二步：对 Person 类做如下修改，使用 @Autowired 注解，并通过 get 方法获取 school 对象 public class Person { @Autowired private School school; public School getSchool() { return school; } } 第三步：新建对应的 bean 对象 第四步：新建测试方法，注意类型的强制转换，以使用 get 方法 @Test public void get() { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\"beans.xml\"); Person person = (Person) beanFactory.getBean(\"person\"); System.out.println(person.getSchool()); } 至此，通过 @Autowired 注解实现了对象的自动装配。注意，是对象的自动装配，对应 bean 对象依旧是手动创建 若是取消 @Autowired 注解，再运行测试程序，则 school 对象的引用为 null public class Person { // @Autowired private School school; public School getSchool() { return school; } public void setSchool(School school) { this.school = school; } } 上述是不使用 @Autowired 注解进行自动化装配，所需要进行的步骤。可以看出，@Autowired 实际是省略了 set、有参注入与 bean 对象的引用 @Qualifier 注解可以指定注入的接口类的具体某一个实现类 @Resource 对于 @Resource 注解，是由 JDK 提供，并非 Spring 自带，若无法正常引入，则导入如下依赖 若是依旧失败，请清空 Maven 依赖，再次下载，个人的经验之谈 javax.annotation javax.annotation-api 1.3.1 在使用上，@Resource注解与@Autowired注解类似，但请仔细观察下方示例 public class Person { @Resource private School school; public School getSchool() { return school; } public void setSchool(School school) { this.school = school; } } 运行测试方法，竟然可以正确的输出，但 bean 的 id 是错误的。此时，将自动装配注解切换回 @Autowired，会发现控制台报错！ 小结 对于 @Resource 注解，最大的不同是，它会再根据类型匹配，即 byType。而对于 @Autowired，若是无法匹配到对应 bean 的 id，则直接匹配失败，属于 byName 通俗些说，@Autowired 自动注入是基于 bean 对象的 id 值；@Resource 也是基于 id 值，但会在匹配失败后根据 class 属性值再次匹配 扫描器 在之前，完成了 bean 对象的自动装配，但仍然需要手动在 IoC 容器中创建 bean 对象 Spring 中存在扫描器的概念，可以将某一部分 Java 设为 bean 对象，进行管理 在 beans.xml 中开启扫描器配置，示例如下，将 com 以及子包中的 Java 类设为 bean 对象 对于 Spring 的配置，其中的命名空间、设置开启等，请参考 Spring 文档中对于这些部分做的说明 此时，对于beans.xml中定义的bean对象，已经没有存在的必要，而自动装配依旧可以完成，示例如下 @Component public class School { } @Component public class Person { @Resource private School school; public School getSchool() { return school; } } @Test public void get() { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\"beans.xml\"); Person person = (Person) beanFactory.getBean(\"person\"); System.out.println(person.getSchool()); } 可以看到，在 beans.xml 中开启 beans 扫描器以后，需要在管理的 Java 类上添加注解 @Component Java 的开发遵循 MVC 三层设计，存在 Controller、Service、Dao 三个层。Spring 为这三个层提供了对应的注解 @Controller、@Service、@Repository，其余不属于这三层的统一使用 @Component 注解 也就是说，在 beans.xml 中开启扫描器，依旧需要在对应的 Java 类上配置注解 Java 类配置注解为 bean 对象，bean 对象的 id 默认为类名首字母小写 可以指定 bean 对象的别名，通过 @Component 等注解，这不影响扫描器赋予的默认 id 当然，对于 Java 程序的开发，还请务必遵循规范进行 注解开发 在 Spring 中，已经可以实现纯注解的形式进行开发，无须再配置 beans.xml 在 Spring 中，常用的注解大致如下 注解 位置 作用 @Configuration 类 应用程序配置，取代 beans.xml @Bean 方法 返回单例 Bean，用于组件集成 @ComponentScan 类 扫描器的注解配置 @Value 字段 为成员属性赋值 @Component、@Controller、@Service、@Repository 类 将 Java 类声明为 bean 对象 @Resource、@Autowired 字段、set 方法、构造方法 bean 对象的自动化装配 @PropertySource 类 加载外部 property 配置文件 以下，通过实际的案例，对上述的部分注解做运用，理解 Spring 的纯注解开发方式，注意其中的细节！ 第一步：创建应用程序配置的Java类 @Configuration @ComponentScan(basePackages = \"com.config\") @PropertySource(value = {\"classpath:jdbc.properties\"}) public class SpringBeans { @Bean public DataSource getDataSource() { return new DataSource(); } } 第二步：新建外部的properties属性配置文件 jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/rent?serverTimezone=Asia/Shanghai jdbc.username=root jdbc.password=123456 第三步：新建DataSource类 @Component public class DataSource { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String root; @Value(\"${jdbc.password}\") private String password; @Override public String toString() { return \"DataSource{\" + \"driver='\" + driver + '\\'' + \", url='\" + url + '\\'' + \", root='\" + root + '\\'' + \", password='\" + password + '\\'' + '}'; } } 第四步：编写测试代码 @Test public void get() { ApplicationContext beanFactory = new AnnotationConfigApplicationContext(SpringBeans.class); DataSource dataSource = (DataSource) beanFactory.getBean(\"dataSource\"); System.out.println(dataSource); } 上述的四个步骤，简单的演示了基于纯注解的 Spring 配置 其中，对于之前介绍的部分 Spring 注解有了应用，例如 @ComponentScan(basePackages = \"com.config\")，取代了 XML 中定义的扫描器。另外，获取应用程序的 class 文件必须使用 AnnotationConfigApplicationContext 实现类，不再是读取 XML 配置 当然，纯注解开发的方法固然简便，却不是主流，依旧是以稳重的 XML 为重。纯粹的 Spring 注解开发，需要以 SpringBoot 实现，在原生的 Spring 开发中，配置文件极为繁琐，XML 优于纯注解 作用域 Spring 中管理的 bean 对象存在作用域，分为两类 作用域 定义 singleton 单例作用域，一个 bean 对象在程序运行时只存在一个 bean 实例 prototype 一个 bean 对象可以存在多个 bean 实例 默认不声明的情况下，bean 对象为单例作用域 作用域 定义 request 一次 http 的 request 请求 session 一次 htpp 的 session 会话 application 一次 spring 程序的运行，相当于 ServletContext websocket 单个 websocket 的连接 Spring 中，bean 的作用域，还存在四种，只可以应用于 WEB 环境中 对于作用域的声明，是 bean 对象的 scope 属性，注解则为 @Scope(value = \"XXX\") 延迟加载 在 Spring 中的 bean 对象，默认在容器加载时，可以选择是否延迟初始化，默认 bean 对象在容器启动时初始化 @Component @Lazy(value = true) public class PersonA { public PersonA() { System.out.println(\"A延迟初始化......\"); } } @Component @Lazy(value = false) public class PersonB { public PersonB() { System.out.println(\"B延迟初始化......\"); } } 若使用 XML 配置，则在 bean 对象中定义属性 lazy-init，默认为 true，即延迟初始化，bean 对象不与容器同步加载。若设置为 false，bean 对象会在需要时再加载实例化 对于 bean 对象是否需要延迟初始化，根据实际的应用场景判断 生命周期 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-07 12:56:01 "},"令人敬畏的春天/手搓IOC容器.html":{"url":"令人敬畏的春天/手搓IOC容器.html","title":"手搓 IOC 容器","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"令人敬畏的春天/AOP面向切面.html":{"url":"令人敬畏的春天/AOP面向切面.html","title":"AOP 面向切面","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"令人敬畏的春天/分析AOP代理.html":{"url":"令人敬畏的春天/分析AOP代理.html","title":"分析 AOP 代理","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"令人敬畏的春天/SpringServlet.html":{"url":"令人敬畏的春天/SpringServlet.html","title":"Spring Servlet","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"令人敬畏的春天/SpringBoot.html":{"url":"令人敬畏的春天/SpringBoot.html","title":"Spring Boot","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-02 23:03:58 "},"Rust/":{"url":"Rust/","title":"Rust","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-08 20:18:23 "},"Rust/Rust基础.html":{"url":"Rust/Rust基础.html","title":"Rust 基础","keywords":"","body":"变量与可变性 初次看到这个标题的时候，个人是有些懵的！不应该是变量与不可变性吗？ 不然，Rust 中的变量默认不可变，你需要改变自己的认知。换想一下，变量的 默认可变真的好吗？ let a = 100; let b = '1'; println!(\"{} {}\", a, b) 上述是 Rust 变量的代码演示。变量使用 关键字 let 声明，可以自动的判断数据的所属类型 需要注意的是，Rust 中的打印输出语句，需要一个占位符，这并不是什么大问题。相反，必要的严谨会带来不错的体验 Rust 中的变量默认不可变。但在需要的时候，依旧可以改变变量的数据 let mut a = 100; a = 200; println!(\"{}\", a); 在 let 关键字与变量名之间，加入 mut 关键字，该变量就 具有可变性，修改其中的数据（不可变更数据的类型） 接下来，介绍 Rust 中的常量。常量使用 const 关键字定义，其中的数据一经定义则无法修改，也无法使用关键字 mut const NEW_YEAR: i32 = 2021; println!(\"{}\", NEW_YEAR); 上述的常量代码中，可以注意到，i32，在 Rust 为有符号整数三十二位，即 Rust 的常量必须指定其数据的类型，而默认的不可变变量则可以自动判断 除此之外，Rust 中还存在隐藏变量的设定，隐藏变量的对象不可以是常量 let a = 100; let a = a + 100; let a = \"AA\"; println!(\"{}\", a); 隐藏变量很好理解，通过声明同样名称的变量，隐藏之前声明的变量。上述的代码中，变量 a 第三次可以接收字符串，而之前是整数。隐藏变量的实质，是与之前变量同名的全新变量 这与之前的let mut完全不同，隐藏不了不仅可以修改数据的内容，也 可以改变元素的类型，它的作用是 重复利用变量名 数据类型 没错，Rust 中也存在数据类型的概念，切较为严格。之前，只是 Rust 可以自动的判断出数据的所属类型 Rust 是 静态类型语言，在 程序编译时，必须知道每个数据的所属类型 值得一提，Rust 中的数据类型也可以分为两类，标量类型、复合类型，可以理解为 Java 中的原始、引用两个类型 标量类型 先说整型，Rust 存在十二种整型类型。是的，你没有听错，不是 Java 中的四种 字节 有符号 无符号 8 bit i8 u8 16 bit i16 u16 32 bit i32 u32 64 bit i64 u64 128 bit i128 u128 arch isize usize 熟悉的感觉又回来了。Rust 只是将 Java 中的四个整型类型，细分为了有符号、无符号。同时添加了 128bit 的整型。真正存在差异的是 arch 类型 arch 类型的实际字节长度，是根据计算机架构决定的，在 64、32 位架构上，它的字节长度也就是 64、32 位 Rust 的默认整型是 32bit，当将整数字面量赋予变量时，默认接收的类型就是 32bit（i32），有符号三十二位字节 let a = 2147483647; println!(\"{}\", a); 在上述的代码示例中，取到了有符号 32 位 bit 的最大值 2147483647，之后加 1，则编译错误，超出了当前类型的取值范围 对于变量类型的声明，存在另一种写法。let a: u32 = 100; 与 let a = 100u32; 的作用是一致的。这种写法，不支持字节型（i16、u16） 再说浮点型，存在 f32、f64，分别代表单精度浮点、双精度浮点。默认的浮点类型是 f64，采用 IEEE-754 标准 let a: f32 = 100.0; let b: f64 = 200.0; 之后的布尔类型、字符类型，用法如下，无明显不同 let a: bool = true; let b: char = 'A'; 复合类型 多个类型组合成的类型，称为复合类型，理解为 Java 中的引用类型。Rust 中存在两个原生的复合类型，数组与元组，学习过 Python 的人应该会了解元组的概念 // 元组的声明 let t: (i16, char, bool) = (12, '1', true); // 元组解构 let (x, y, z) = t; println!(\"{}\", x); // 索引结构 println!(\"{}\", t.0); 上述代码介绍了元组的定义与使用。一个 元组中可以声明多个不同的数据类型，同时，可以通过 元组解构，单独使用其中的数据，支持索引结构的方式（索引从 0 开始） // 数组的基本定义，直接存储数据，再确定长度、类型 let array = [1, 2, 3, 4, 5, 6]; // 事先声明数组的类型、长度，再存储数据 // 声明数据长度为 3 数据类型为 i16 let array: [i16; 3] = [1, 2, 3]; // 批量声明数据 定义 3 个整型 i32 数据 10 let array = [10; 3]; // 数组数据的索引取出 println!(\"{}\", array[2]); 元组与数组类似，长度已经定义，则无法改变。但数组中的数据类型唯一！ Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-09 11:57:30 "},"Rust/所有权.html":{"url":"Rust/所有权.html","title":"所有权","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-08 20:18:23 "},"Rust/结构体.html":{"url":"Rust/结构体.html","title":"结构体","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-08 20:18:23 "},"个人的随笔小记/2021年.html":{"url":"个人的随笔小记/2021年.html","title":"2021 年","keywords":"","body":"六月 八号 天气炎热，浑身泛力，没有空调，昏昏欲睡 九号 课多、事累，垃圾学校 七月 八月 Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-09 13:12:29 "},"个人的随笔小记/2022年.html":{"url":"个人的随笔小记/2022年.html","title":"2022 年","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-08 12:07:07 "},"个人的随笔小记/2023年.html":{"url":"个人的随笔小记/2023年.html","title":"2022 年","keywords":"","body":"Mr.Zhou Blog - GitHub PagesLast updated at： 2021-06-08 12:07:07 "}}