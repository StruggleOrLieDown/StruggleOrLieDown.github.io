# 抽象的概念

Java 中的抽象存在两个体现，` 抽象类 `、` 抽象方法 `

` 抽象类 `： 抽象存在的类，现实中找不到该类的实际存在（概念存在）

` 抽象方法 `： 存在于抽象类中的方法，**不存在方法体**

` 抽象类 ` 的语法结构：`public abstract class 类名 {}`

` 抽象方法 ` 的语法结构：`public abstract 方法名 ();`

抽象类的理解，可以参考 [` 白马非马 `](https://baike.so.com/doc/44622-46627.html)
- 动物是抽象的概念，相对于它，马是具体的概念
- 马是抽象的概念，相对于它，白马是具体的概念

基于 ` 白马非马 `，抽象类的第一特征： **抽象类无法实例化对象**

然而，抽象类可以被普通类继承，基于 ` 类的继承 `： **抽象类存在构造方法**

抽象类定义的方法为所有子类共有， **抽象子类必须重写抽象类定义的所有抽象方法**

但是，当 **子类也为抽象类** 时，则无需重写

> 抽象方法重写的意义在于，子类的的同一方法具有不同的实现，无法由父类统一

抽象类主要是用于 **定义公共的模板**，相当于一种规范，对于子类的规范，
抽象方法则是抽象类定义的规范的组成部分

简单的理解，抽象类定义了实现的模板，而继承的 **子类则对其内容加以实现**

值得注意的是：
- **抽象类中可以存在非抽象方法，而抽象方法所在的类则必须是抽象类**
- 抽象方法必须被抽象子类重写，所以 **抽象方法不可使用 `private`**

# 接口的概念

接口的出现，弥补 **Java 中不可以多继承** 的问题，**一个类可以实现多个接口**

简单的理解，接口是基于抽象的增强，且为 Java 实现了 “多继承”

` 接口类 ` 的语法结构：`public interface class 类名 {}`

接口与抽象，存在相同，也存在不同，需要仔细鉴别

接口存在一些需要注意的地方，相对于抽象类

- 定义接口的关键字是 `interface` ，位于类名之前
- 实现接口的关键字是 `implements` ，`implements` 排在 `extends` 后面
- 接口是被其它 Java 类 ` 实现 ` 而非 ` 继承 `，不可以实例化的同时，也不存在构造方法
- 接口中定义的抽象方法，也必须被实现类重写
- 若接口类作为方法的形参，则传入的实参可以是实现该接口的子类对象

对于接口类、接口方法，存在 **默认的前缀修饰符**

- 接口中的成员属性：默认修饰符 `public static final`，全局、静态、常量
- 接口中的成员方法：默认修饰符 `public abstract`，公共、抽象

在接口类中，可以定义存在方法体的普通方法

- 接口类可以定义 `static 静态非抽象方法 `，存在方法体
- 接口类可以定义 `default 默认非抽象方法 `，存在方法体

# 抽象与接口的理解

可以看到，抽象与接口都存在关键字 `abstract`，且不与 `static`、`final`、`private` 共存

核心在于，**`abstract` 抽象方法，必须被子类在继承的前提下，进行方法的重写**

抽象和接口看似相同，但实际上，二者的定位是有区分的

简单的理解，抽象类是抽取某个群体中的共有方法，而接口则是代表其中某些个体所具备的独有方法

以鸟这个抽象的概念为例（切勿较真，只作举例）

鸟会飞，所以的鸟都会飞 `--->` 抽象类则定义了 “飞” 这个抽象方法（公有）

企鹅也是鸟类，但企鹅会游泳 `--->` 接口类则定义了“游泳” 这个接口方法（独有）

**一个类在具备共有方法的同时，也存在着多个特有方法** 

单继承：继承共有方法，抽象类、普通类定义子类共有

多实现：实现特有方法，接口定义子类特有
