# 类的多态

多态：一种类型声明的的变量，可以引用多种实际类型对象

多态的实现存在三个前提（不满足则不构成类的多态）

1. 继承：子类继承父类属性、方法
2. 方法重写：子类重写父类方法
3. 向上转型：**子类实例对象赋值给父类引用变量**

- 子类实例对象：`new Son();`
- 父类引用变量：`Father father;`

简单的说，子类重写了父类的实例方法，且子类对象赋值给了父类变量，这就是类的多态、多种形态

类的多态中，分为两个重要的点（务必注意，多态理解的核心）

1. 多态的向上、向下转型
2. 多态的静态、动态绑定

# 多态的向上转型

多态的向上转型：当子类实例变量赋值给父类引用变量

`Father father = new Son();`

多态的向上转型：（构成多态）

1. 父类引用变量可以调用子类重写的父类方法
2. 父类引用变量不可以调用子类中独有的方法

# 多态的向下转型

多态的向下转型：将向上转型的父类引用变量再强转会子类引用变量

`Son son = (Son) father;`

> 多态的向下转型，实质就是转换为原来的类型，向下转型之后不构成 ` 类的多态 `

多态的向下转型：（不构成多态）

1. 必须以多态的向上转型为前提条件（先向下，再向上）
2. 在向下转型的过程中必须是 **强制类型转换**
3. 为了避免类型转换异常，可以通过关键字 `instanceof` 判断
4. 多态向下转型后，子类引用变量可以 **调用子类特有的方法**

**`instanceof` 关键字用于比较两个类是否存在继承关系**

# 多态的静态绑定

静态绑定：在程序编译时确定的方法（子类无法重写的父类静态方法）

`编译时类型 变量 = new 运行时类型();`

简单的理解，根据子类是否存在，父类的同名静态方法

- 若子类存在同名静态方法，调用子类实现（就近原则，以 new 的实例对象为准）
- 若子类不存在同名静态方法，调用父类实现

# 多态的动态绑定

动态绑定：在程序运行时确定的属性、方法，以右侧运行时类型为准

> 静态绑定针对的是 static 类属性，而动态则是实例属性、实例方法

当多态向上转型的父类引用变量，调用父类、子类中同名的属性、方法时，实际调用的是子类重写的父类方法（实例属性、实例方法）

简单的理解，一个类重写了 `toString()`，再通过该类对象调用，则不再是 `Object`

**子类重写了父类的实例方法，且在右侧实例对象是子类时，则调用子类的实现**

# 继承中的执行顺序

在 Java 的继承中，父类、子类的各种属性、方法、代码块，存在不同的执行优先级

> 若属性、方法、代码块的优先级相同，则顺序执行

1. 父类静态字段、静态代码块
2. 子类静态字段、静态代码块
3. 父类成员变量、非静态代码块
4. 父类构造方法
5. 子类成员变量、非静态代码块
6. 子类构造器

简单的理解，父类、子类的静态部分是第一优先级，其次是父类其他部分、最后是子类

值得注意的是，构造方法的执行优先级，低于实例属性、方法

这也是为了方便 **通过构造方法，为对象的实例属性赋值**
