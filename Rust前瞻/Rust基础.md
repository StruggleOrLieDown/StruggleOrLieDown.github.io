# 变量与可变性

初次看到这个标题的时候，个人是有些懵的！不应该是变量与不可变性吗？

不然，**Rust 中的变量默认不可变**，你需要改变自己的认知。换想一下，变量的默认可变真的好吗？

```Rust
let a = 100;
let b = '1';
println!("{} {}", a, b)
```

上述是 Rust 变量的代码演示。变量使用 **关键字 let 声明**，可以自动的判断数据的所属类型

需要注意的是，Rust 中的打印输出语句，需要一个占位符，这并不是什么大问题。相反，必要的严谨会带来不错的体验

Rust 中的变量默认不可变。但在需要的时候，依旧可以改变变量的数据

```Rust
let mut a = 100;
a = 200;
println!("{}", a);
```

在 let 关键字与变量名之间，加入 **mut 关键字**，该变量就 **具有可变性**，修改其中的数据（不可变更数据的类型）

接下来，介绍 Rust 中的常量。常量使用 const 关键字定义，其中的数据一经定义则无法修改，也无法使用关键字 mut

```Rust
const NEW_YEAR: i32 = 2021;
println!("{}", NEW_YEAR);
```

上述的常量代码中，可以注意到，**i32，在 Rust 为有符号整数三十二位**，即 Rust 的常量必须指定其数据的类型，而默认的不可变变量则可以自动判断

除此之外，Rust 中还存在隐藏变量的设定，**隐藏变量的对象不可以是常量**

```Rust
let a = 100;
let a = a + 100;
let a = "AA";
println!("{}", a);
```

隐藏变量很好理解，通过声明同样名称的变量，隐藏之前声明的变量。上述的代码中，变量 a 第三次可以接收字符串，而之前是整数。**隐藏变量的实质，是与之前变量同名的全新变量**

这与之前的`let mut`完全不同，隐藏不了不仅可以修改数据的内容，也 **可以改变元素的类型**，它的作用是 **重复利用变量名**

# 数据类型

没错，Rust 中也存在数据类型的概念，切较为严格。之前，只是 Rust 可以自动的判断出数据的所属类型

Rust 是 **静态类型语言**，在 **程序编译时，必须知道每个数据的所属类型**

值得一提，Rust 中的数据类型也可以分为两类，标量类型、复合类型，可以理解为 Java 中的原始、引用两个类型

## 标量类型

先说整型，Rust 存在十二种整型类型。是的，你没有听错，不是 Java 中的四种

|字节|有符号|无符号|
|:-|:-|:-|
|8 bit|i8|u8|
|16 bit|i16|u16|
|32 bit|i32|u32|
|64 bit|i64|u64|
|128 bit|i128|u128|
|arch|isize|usize|

熟悉的感觉又回来了。Rust 只是将 Java 中的四个整型类型，细分为了有符号、无符号。同时添加了 128bit 的整型。真正存在差异的是 arch 类型

arch 类型的实际字节长度，是根据计算机架构决定的，在 64、32 位架构上，它的字节长度也就是 64、32 位

Rust 的默认整型是 32bit，当将整数字面量赋予变量时，默认接收的类型就是 32bit（i32），有符号三十二位字节

```Rust
let a = 2147483647;
println!("{}", a);
```

在上述的代码示例中，取到了有符号 32 位 bit 的最大值 2147483647，之后加 1，则编译错误，超出了当前类型的取值范围

对于变量类型的声明，存在另一种写法。`let a: u32 = 100;` 与 `let a = 100u32;` 的作用是一致的。这种写法，不支持字节型（i16、u16）

再说浮点型，存在 f32、f64，分别代表单精度浮点、双精度浮点。默认的浮点类型是 f64，采用 IEEE-754 标准

```Rust
let a: f32 = 100.0;
let b: f64 = 200.0;
```

之后的布尔类型、字符类型，用法如下，无明显不同

```Rust
let a: bool = true;
let b: char = 'A';
```

## 复合类型

多个类型组合成的类型，称为复合类型，理解为 Java 中的引用类型。Rust 中存在两个原生的复合类型，数组与元组，学习过 Python 的人应该会了解元组的概念
 
 ```rust
// 元组的声明
let t: (i16, char, bool) = (12, '1', true);
// 元组解构
let (x, y, z) = t;
println!("{}", x);
// 索引结构
println!("{}", t.0);
 ```

上述代码介绍了元组的定义与使用。一个 **元组中可以声明多个不同的数据类型**，同时，可以通过 **元组解构**，**单独使用其中的数据**，支持索引结构的方式（索引从 0 开始）

```rust
// 数组的基本定义，直接存储数据，再确定长度、类型
let array = [1, 2, 3, 4, 5, 6];
// 事先声明数组的类型、长度，再存储数据
// 声明数据长度为 3 数据类型为 i16
let array: [i16; 3] = [1, 2, 3];
// 批量声明数据 定义 3 个整型 i32 数据 10
let array = [10; 3];
// 数组数据的索引取出
println!("{}", array[2]);
```

元组与数组类似，长度已经定义，则无法改变。但数组中的数据类型唯一！ 







