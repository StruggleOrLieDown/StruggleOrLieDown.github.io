# 泛型的概念

泛型，意为广泛的类型。它可以为容器中存储的类型限定一个范围。这个范围可以是具体的类或其子类、父类。对于泛型的定义，是作为参数传入到容器中，例如 `public class 类名 <泛型符号, 泛型符号> {}`

对于泛型，可以被应用与类、接口、方法、属性中，**泛型只允许为引用类型**

**对于广泛的类型**：可以使用泛型作为占位符，当实际使用时，再指定实际的类型

**对于类型参数化**：作为一个参数传入，并在程序编译后，替代为具体的类型，即 **泛型擦除**

**对于类型安全**：当指定具体的类型时，Java 编译器会判断类型转换的合法性，规避 `ClassCastExcepttion`

泛型是开发中的一大利器，动态的设置参数的类型，使得程序更为灵活、易用，若不指定，则默认为 Object

对于泛型的认识，需要注意泛型使用的符号的含义，理解泛型擦除的概念

泛型擦除：**Java 编译器将泛型符号替换为 Object，再转换为具体的类型**

在 Java 中，泛型根据功能定位的不同，可以分为以下几类。当然，可以自定义，大多无实际意义

| 泛型符号 | 符号说明 |
|:-:    |:-    |
|E      | 容器元素 |
|T      | 普通 Java 类 |
|K      | 键     |
|V      | 值     |
|N      | 数值类型 |

泛型的符号定义、符号数量无限制，但一般使用具有特定含义的符号

> `?` 存在特殊含义 -> 无界通配符，其余的泛型符号可以变更，不存在特殊作用

对于泛型类、泛型接口、泛型方法：**泛型方法可以使用泛型类、泛型接口定义的泛型符号**

# 泛型类

泛型类的语法结构：`public class 类名 <泛型符号, 泛型符号> {}`

当一个类定义为泛型类时，它的泛型符号可以被其属性、方法使用

**注意！属性不可以独自声明为泛型，只可以接收自泛型类、泛型接口**

泛型类的示例

```java
public class Person<T, N> {
	private T name;
	private N age;

	public Person(T name, N age) {
		this.name = name;
		this.age = age;
	}

	public T getName() {
		return name;
	}

	public void setName(T name) {
		this.name = name;
	}

	public N getAge() {
		return age;
	}

	public void setAge(N age) {
		this.age = age;
	}
}
```

上述是一个典型的泛型类，它定义了两个泛型符号，T、N

泛型类、接口、方法在被使用时，必须声明其实际的类型，不再是泛型符号

```java
Person<String, Integer> person = new Person<>("张三", 29);
```

# 泛型接口

泛型接口的语法结构：`public interface 接口名 <泛型符号> {}`

泛型接口与泛型类相似，以下是泛型接口及实现的代码示例

```java
public interface Animal<T> {
	T food();
}
```

```java
public class FishImpl implements Animal<String> {
	@Override
	public String food() {
		return null;
	}
}
```

同样的，在继承、实现泛型类、泛型接口时，也必须指定具体的类型替代泛型占位符

当然，也可以继续使用泛型符号，如同抽象子类也无须重写抽象父类的抽象方法

# 泛型方法

泛型方法的语法结构：`public 泛型符号 方法名 (泛型符号 参数名) {}`

**泛型方法的泛型符号，位于 ` 修饰符 ` 和 ` 返回值类型 ` 之间，返回值类型也可以定义为泛型**

> 当使用泛型代替返回值类型时，无需尖括号 `<>`，仅限于非静态泛型方法
>
> 返回值类型的泛型符号不可独自声明，必须与泛型类、接口、方法一致

泛型方法分为静态、非静态，以下是方法声明泛型符号时的注意点

1. 泛型方法的实际类型无需声明，根据传入的参数值由编译器确定
2. **对于静态泛型方法，它的泛型符号必须由当前方法定义**
3. 对于非静态泛型方法，可以向上使用泛型类、泛型接口的泛型符号

对于实例泛型方法，它的泛型符号可以由泛型类、泛型接口指定

对于静态泛型方法，它的泛型符号仅可以自定义、自使用，不可接收泛型类、泛型接口的泛型符号

**静态属性、静态方法在程序编译时确定，不可使用泛型类定义的泛型符号**

静态、非静态泛型方法代码示例

```java
public class Ma<N> {
	public static <T> T get(T food) {
		return food;
	}

	public N set(N number) {
		return number;
	}
}
```

```java
System.out.println(Ma.get("皮皮虾"));
Ma<Integer> integerMa = new Ma<>();
integerMa.set(123);
```

值得注意的是

1. 由于泛型类型的不确定性，多个泛型之间不可以进行相加等修改操作
2. 当然，这并不影响泛型类型的元素遍历等非修改操作
